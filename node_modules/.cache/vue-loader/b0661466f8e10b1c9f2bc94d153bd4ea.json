{"remainingRequest":"/Users/xieronghuo/jnd-demo/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/xieronghuo/jnd-demo/node_modules/view-design/src/components/table/table.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/xieronghuo/jnd-demo/node_modules/view-design/src/components/table/table.vue","mtime":1602570644000},{"path":"/Users/xieronghuo/jnd-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xieronghuo/jnd-demo/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/xieronghuo/jnd-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xieronghuo/jnd-demo/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCiAgICBpbXBvcnQgdGFibGVIZWFkIGZyb20gJy4vdGFibGUtaGVhZC52dWUnOwogICAgaW1wb3J0IHRhYmxlQm9keSBmcm9tICcuL3RhYmxlLWJvZHkudnVlJzsKICAgIGltcG9ydCB0YWJsZVN1bW1hcnkgZnJvbSAnLi9zdW1tYXJ5LnZ1ZSc7CiAgICBpbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24udnVlJzsKICAgIGltcG9ydCBEcm9wZG93bk1lbnUgZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24tbWVudS52dWUnOwogICAgaW1wb3J0IFNwaW4gZnJvbSAnLi4vc3Bpbi9zcGluLnZ1ZSc7CiAgICBpbXBvcnQgeyBvbmVPZiwgZ2V0U3R5bGUsIGRlZXBDb3B5LCBnZXRTY3JvbGxCYXJTaXplIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzaXN0JzsKICAgIGltcG9ydCB7IG9uLCBvZmYgfSBmcm9tICcuLi8uLi91dGlscy9kb20nOwogICAgaW1wb3J0IENzdiBmcm9tICcuLi8uLi91dGlscy9jc3YnOwogICAgaW1wb3J0IEV4cG9ydENzdiBmcm9tICcuL2V4cG9ydC1jc3YnOwogICAgaW1wb3J0IExvY2FsZSBmcm9tICcuLi8uLi9taXhpbnMvbG9jYWxlJzsKICAgIGltcG9ydCBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7CiAgICBpbXBvcnQgeyBnZXRBbGxDb2x1bW5zLCBjb252ZXJ0VG9Sb3dzLCBjb252ZXJ0Q29sdW1uT3JkZXIsIGdldFJhbmRvbVN0ciB9IGZyb20gJy4vdXRpbCc7CgogICAgY29uc3QgcHJlZml4Q2xzID0gJ2l2dS10YWJsZSc7CgogICAgbGV0IHJvd0tleSA9IDE7CiAgICBsZXQgY29sdW1uS2V5ID0gMTsKCiAgICBleHBvcnQgZGVmYXVsdCB7CiAgICAgICAgbmFtZTogJ1RhYmxlJywKICAgICAgICBtaXhpbnM6IFsgTG9jYWxlIF0sCiAgICAgICAgY29tcG9uZW50czogeyB0YWJsZUhlYWQsIHRhYmxlQm9keSwgdGFibGVTdW1tYXJ5LCBTcGluLCBEcm9wZG93biwgRHJvcGRvd25NZW51IH0sCiAgICAgICAgcHJvdmlkZSAoKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICB0YWJsZVJvb3Q6IHRoaXMKICAgICAgICAgICAgfTsKICAgICAgICB9LAogICAgICAgIHByb3BzOiB7CiAgICAgICAgICAgIGRhdGE6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEFycmF5LAogICAgICAgICAgICAgICAgZGVmYXVsdCAoKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBjb2x1bW5zOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBBcnJheSwKICAgICAgICAgICAgICAgIGRlZmF1bHQgKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgc2l6ZTogewogICAgICAgICAgICAgICAgdmFsaWRhdG9yICh2YWx1ZSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBvbmVPZih2YWx1ZSwgWydzbWFsbCcsICdsYXJnZScsICdkZWZhdWx0J10pOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGRlZmF1bHQgKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy4kSVZJRVcgfHwgdGhpcy4kSVZJRVcuc2l6ZSA9PT0gJycgPyAnZGVmYXVsdCcgOiB0aGlzLiRJVklFVy5zaXplOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICB3aWR0aDogewogICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXQogICAgICAgICAgICB9LAogICAgICAgICAgICBoZWlnaHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10KICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gMy40LjAKICAgICAgICAgICAgbWF4SGVpZ2h0OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN0cmlwZTogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGJvcmRlcjogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNob3dIZWFkZXI6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhpZ2hsaWdodFJvdzogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHJvd0NsYXNzTmFtZTogewogICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sCiAgICAgICAgICAgICAgICBkZWZhdWx0ICgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNvbnRleHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IE9iamVjdAogICAgICAgICAgICB9LAogICAgICAgICAgICBub0RhdGFUZXh0OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbm9GaWx0ZXJlZERhdGFUZXh0OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGlzYWJsZWRIb3ZlcjogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbgogICAgICAgICAgICB9LAogICAgICAgICAgICBsb2FkaW5nOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZHJhZ2dhYmxlOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9vbHRpcFRoZW1lOiB7CiAgICAgICAgICAgICAgICB2YWxpZGF0b3IgKHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uZU9mKHZhbHVlLCBbJ2RhcmsnLCAnbGlnaHQnXSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZGVmYXVsdDogJ2RhcmsnCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vICM1MzgwIOW8gOWQr+WQju+8jDprZXkg5by65Yi25pu05paw77yM5ZCm5YiZ5L2/55SoIGluZGV4CiAgICAgICAgICAgIC8vIDQuMSDlvIDlp4vmlK/mjIEgU3RyaW5n77yM5oyH5a6a5YW35L2T5a2X5q61CiAgICAgICAgICAgIHJvd0tleTogewogICAgICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjAuMAogICAgICAgICAgICBzcGFuTWV0aG9kOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBGdW5jdGlvbgogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjAuMAogICAgICAgICAgICBzaG93U3VtbWFyeTogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMC4wCiAgICAgICAgICAgIHN1bW1hcnlNZXRob2Q6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMC4wCiAgICAgICAgICAgIHN1bVRleHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZwogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjEuMAogICAgICAgICAgICBpbmRlbnRTaXplOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxNgogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjEuMAogICAgICAgICAgICBsb2FkRGF0YTogewogICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24KICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gNC40LjAKICAgICAgICAgICAgdXBkYXRlU2hvd0NoaWxkcmVuOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gNC4xLjAKICAgICAgICAgICAgY29udGV4dE1lbnU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjIuMAogICAgICAgICAgICBzaG93Q29udGV4dE1lbnU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBkYXRhICgpIHsKICAgICAgICAgICAgY29uc3QgY29sc1dpdGhJZCA9IHRoaXMubWFrZUNvbHVtbnNJZCh0aGlzLmNvbHVtbnMpOwogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgcmVhZHk6IGZhbHNlLAogICAgICAgICAgICAgICAgdGFibGVXaWR0aDogMCwKICAgICAgICAgICAgICAgIGNvbHVtbnNXaWR0aDoge30sCiAgICAgICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscywKICAgICAgICAgICAgICAgIGNvbXBpbGVkVWlkczogW10sCiAgICAgICAgICAgICAgICBvYmpEYXRhOiB0aGlzLm1ha2VPYmpEYXRhKCksICAgICAvLyBjaGVja2JveCBvciBoaWdobGlnaHQtcm93CiAgICAgICAgICAgICAgICByZWJ1aWxkRGF0YTogW10sICAgIC8vIGZvciBzb3J0IG9yIGZpbHRlcgogICAgICAgICAgICAgICAgY2xvbmVDb2x1bW5zOiB0aGlzLm1ha2VDb2x1bW5zKGNvbHNXaXRoSWQpLAogICAgICAgICAgICAgICAgY29sdW1uUm93czogdGhpcy5tYWtlQ29sdW1uUm93cyhmYWxzZSwgY29sc1dpdGhJZCksCiAgICAgICAgICAgICAgICBsZWZ0Rml4ZWRDb2x1bW5Sb3dzOiB0aGlzLm1ha2VDb2x1bW5Sb3dzKCdsZWZ0JywgY29sc1dpdGhJZCksCiAgICAgICAgICAgICAgICByaWdodEZpeGVkQ29sdW1uUm93czogdGhpcy5tYWtlQ29sdW1uUm93cygncmlnaHQnLCBjb2xzV2l0aElkKSwKICAgICAgICAgICAgICAgIGFsbENvbHVtbnM6IGdldEFsbENvbHVtbnMoY29sc1dpdGhJZCksICAvLyBmb3IgbXVsdGlwbGUgdGFibGUtaGVhZCwgZ2V0IGNvbHVtbnMgdGhhdCBoYXZlIG5vIGNoaWxkcmVuCiAgICAgICAgICAgICAgICBzaG93U2xvdEhlYWRlcjogdHJ1ZSwKICAgICAgICAgICAgICAgIHNob3dTbG90Rm9vdGVyOiB0cnVlLAogICAgICAgICAgICAgICAgYm9keUhlaWdodDogMCwKICAgICAgICAgICAgICAgIHNjcm9sbEJhcldpZHRoOiBnZXRTY3JvbGxCYXJTaXplKCksCiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dDogdGhpcy5jb250ZXh0LAogICAgICAgICAgICAgICAgY2xvbmVEYXRhOiBkZWVwQ29weSh0aGlzLmRhdGEpLCAgICAvLyB3aGVuIENlbGwgaGFzIGEgYnV0dG9uIHRvIGRlbGV0ZSByb3cgZGF0YSwgY2xpY2tDdXJyZW50Um93IHdpbGwgdGhyb3cgYW4gZXJyb3IsIHNvIGNsb25lIGEgZGF0YQogICAgICAgICAgICAgICAgc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyOmZhbHNlLAogICAgICAgICAgICAgICAgc2hvd0hvcml6b250YWxTY3JvbGxCYXI6ZmFsc2UsCiAgICAgICAgICAgICAgICBoZWFkZXJXaWR0aDowLAogICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0OjAsCiAgICAgICAgICAgICAgICBzaG93UmVzaXplTGluZTogZmFsc2UsCiAgICAgICAgICAgICAgICBjb250ZXh0TWVudVZpc2libGU6IGZhbHNlLAogICAgICAgICAgICAgICAgY29udGV4dE1lbnVTdHlsZXM6IHsKICAgICAgICAgICAgICAgICAgICB0b3A6IDAsCiAgICAgICAgICAgICAgICAgICAgbGVmdDogMAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgIH0sCiAgICAgICAgY29tcHV0ZWQ6IHsKICAgICAgICAgICAgbG9jYWxlTm9EYXRhVGV4dCAoKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub0RhdGFUZXh0ID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50KCdpLnRhYmxlLm5vRGF0YVRleHQnKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9EYXRhVGV4dDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgbG9jYWxlTm9GaWx0ZXJlZERhdGFUZXh0ICgpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRmlsdGVyZWREYXRhVGV4dCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudCgnaS50YWJsZS5ub0ZpbHRlcmVkRGF0YVRleHQnKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9GaWx0ZXJlZERhdGFUZXh0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBsb2NhbGVTdW1UZXh0ICgpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1bVRleHQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnQoJ2kudGFibGUuc3VtVGV4dCcpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdW1UZXh0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICB3cmFwQ2xhc3NlcyAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgIGAke3ByZWZpeENsc30td3JhcHBlcmAsCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS1oaWRlYF06ICF0aGlzLnJlYWR5LAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS13aXRoLWhlYWRlcmBdOiB0aGlzLnNob3dTbG90SGVhZGVyLAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS13aXRoLWZvb3RlcmBdOiB0aGlzLnNob3dTbG90Rm9vdGVyLAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS13aXRoLXN1bW1hcnlgXTogdGhpcy5zaG93U3VtbWFyeSwKICAgICAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeENsc30td3JhcHBlci13aXRoLWJvcmRlcmBdOiB0aGlzLmJvcmRlcgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNsYXNzZXMgKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgICBgJHtwcmVmaXhDbHN9YCwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LSR7dGhpcy5zaXplfWBdOiAhIXRoaXMuc2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeENsc30tYm9yZGVyYF06IHRoaXMuYm9yZGVyLAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS1zdHJpcGVgXTogdGhpcy5zdHJpcGUsCiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LXdpdGgtZml4ZWQtdG9wYF06ICEhdGhpcy5oZWlnaHQKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZEhlYWRlckNsYXNzZXMgKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgICAgICAgICBgJHtwcmVmaXhDbHN9LWZpeGVkLWhlYWRlcmAsCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS1maXhlZC1oZWFkZXItd2l0aC1lbXB0eWBdOiAhdGhpcy5yZWJ1aWxkRGF0YS5sZW5ndGgKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICB9LAogICAgICAgICAgICBzdHlsZXMgKCkgewogICAgICAgICAgICAgICAgbGV0IHN0eWxlID0ge307CiAgICAgICAgICAgICAgICBsZXQgc3VtbWFyeUhlaWdodCA9IDA7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93U3VtbWFyeSkgewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpemUgPT09ICdzbWFsbCcpIHN1bW1hcnlIZWlnaHQgPSA0MDsKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNpemUgPT09ICdsYXJnZScpIHN1bW1hcnlIZWlnaHQgPSA2MDsKICAgICAgICAgICAgICAgICAgICBlbHNlIHN1bW1hcnlIZWlnaHQgPSA0ODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCkgewogICAgICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBwYXJzZUludCh0aGlzLmhlaWdodCkgKyBzdW1tYXJ5SGVpZ2h0OwogICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZUludCh0aGlzLm1heEhlaWdodCkgKyBzdW1tYXJ5SGVpZ2h0OwogICAgICAgICAgICAgICAgICAgIHN0eWxlLm1heEhlaWdodCA9IGAke21heEhlaWdodH1weGA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy53aWR0aCkgc3R5bGUud2lkdGggPSBgJHt0aGlzLndpZHRofXB4YDsKICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdGFibGVTdHlsZSAoKSB7CiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhYmxlV2lkdGggIT09IDApIHsKICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSAnJzsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5SGVpZ2h0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy50YWJsZVdpZHRoOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy50YWJsZVdpZHRoIC0gKHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyP3RoaXMuc2Nyb2xsQmFyV2lkdGg6MCk7CiAgICAgICAgICAgICAgICAgICAgfQovLyAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmJvZHlIZWlnaHQgPT09IDAgPyB0aGlzLnRhYmxlV2lkdGggOiB0aGlzLnRhYmxlV2lkdGggLSB0aGlzLnNjcm9sbEJhcldpZHRoOwogICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICB0YWJsZUhlYWRlclN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgaWYgKHRoaXMudGFibGVXaWR0aCAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9ICcnOwogICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy50YWJsZVdpZHRoOwogICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZFRhYmxlU3R5bGUgKCkgewogICAgICAgICAgICAgICAgbGV0IHN0eWxlID0ge307CiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSAwOwogICAgICAgICAgICAgICAgdGhpcy5sZWZ0Rml4ZWRDb2x1bW5zLmZvckVhY2goKGNvbCkgPT4gewogICAgICAgICAgICAgICAgICAgIGlmIChjb2wuZml4ZWQgJiYgY29sLmZpeGVkID09PSAnbGVmdCcpIHdpZHRoICs9IGNvbC5fd2lkdGg7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgOwogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZFJpZ2h0VGFibGVTdHlsZSAoKSB7CiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTsKICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7CiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Rml4ZWRDb2x1bW5zLmZvckVhY2goKGNvbCkgPT4gewogICAgICAgICAgICAgICAgICAgIGlmIChjb2wuZml4ZWQgJiYgY29sLmZpeGVkID09PSAncmlnaHQnKSB3aWR0aCArPSBjb2wuX3dpZHRoOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAvL3dpZHRoICs9IHRoaXMuc2Nyb2xsQmFyV2lkdGg7CiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDsKICAgICAgICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gYCR7dGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXI/dGhpcy5zY3JvbGxCYXJXaWR0aDowfXB4YDsKICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZml4ZWRSaWdodEhlYWRlclN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gMDsKICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmhlYWRlckhlaWdodCsxOwogICAgICAgICAgICAgICAgaWYodGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXIpewogICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5zY3JvbGxCYXJXaWR0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgOwogICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDsKICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgYm9keVN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keUhlaWdodCAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuYm9keUhlaWdodDsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF4SGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLm1heEhlaWdodCA9IGAke2hlaWdodH1weGA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZEJvZHlTdHlsZSAoKSB7CiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlIZWlnaHQgIT09IDApIHsKICAgICAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5ib2R5SGVpZ2h0IC0gKHRoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXI/dGhpcy5zY3JvbGxCYXJXaWR0aDowKTsKICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSB0aGlzLnNob3dIb3Jpem9udGFsU2Nyb2xsQmFyID8gYCR7aGVpZ2h0fXB4YCA6IGAke2hlaWdodCAtIDF9cHhgOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBsZWZ0Rml4ZWRDb2x1bW5zICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0Q29sdW1uT3JkZXIodGhpcy5jbG9uZUNvbHVtbnMsICdsZWZ0Jyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHJpZ2h0Rml4ZWRDb2x1bW5zICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0Q29sdW1uT3JkZXIodGhpcy5jbG9uZUNvbHVtbnMsICdyaWdodCcpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBpc0xlZnRGaXhlZCAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLnNvbWUoY29sID0+IGNvbC5maXhlZCAmJiBjb2wuZml4ZWQgPT09ICdsZWZ0Jyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzUmlnaHRGaXhlZCAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLnNvbWUoY29sID0+IGNvbC5maXhlZCAmJiBjb2wuZml4ZWQgPT09ICdyaWdodCcpOwogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBmb3Igc3VtbWFyeSBkYXRhCiAgICAgICAgICAgIHN1bW1hcnlEYXRhICgpIHsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93U3VtbWFyeSkgcmV0dXJuIHt9OwoKICAgICAgICAgICAgICAgIGxldCBzdW1zID0ge307CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdW1tYXJ5TWV0aG9kKSB7CiAgICAgICAgICAgICAgICAgICAgc3VtcyA9IHRoaXMuc3VtbWFyeU1ldGhvZCh7IGNvbHVtbnM6IHRoaXMuY2xvbmVDb2x1bW5zLCBkYXRhOiB0aGlzLnJlYnVpbGREYXRhIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNvbHVtbi5rZXk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vtc1trZXldID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmtleSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5sb2NhbGVTdW1UZXh0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucmVidWlsZERhdGEubWFwKGl0ZW0gPT4gTnVtYmVyKGl0ZW1bY29sdW1uLmtleV0pKTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9ucyA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90TnVtYmVyID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3ROdW1iZXIgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVjaW1hbCA9ICgnJyArIHZhbHVlKS5zcGxpdCgnLicpWzFdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbnMucHVzaChkZWNpbWFsID8gZGVjaW1hbC5sZW5ndGggOiAwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHByZWNpc2lvbnMpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vdE51bWJlcikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdmFsdWVzLnJlZHVjZSgocHJldiwgY3VycikgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGN1cnIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KChwcmV2ICsgY3VycikudG9GaXhlZChNYXRoLm1pbihwcmVjaXNpb24sIDIwKSkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vtc1trZXldID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmtleSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vtc1trZXldID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmtleSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJycKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4gc3VtczsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgbWV0aG9kczogewogICAgICAgICAgICByb3dDbHNOYW1lIChpbmRleCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93Q2xhc3NOYW1lKHRoaXMuZGF0YVtpbmRleF0sIGluZGV4KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlUmVzaXplICgpIHsKICAgICAgICAgICAgICAgICAgICAvL2xldCB0YWJsZVdpZHRoID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy4kZWwsICd3aWR0aCcpKSAtIDE7CiAgICAgICAgICAgICAgICBsZXQgdGFibGVXaWR0aCA9IHRoaXMuJGVsLm9mZnNldFdpZHRoIC0gMTsKICAgICAgICAgICAgICAgIGxldCBjb2x1bW5zV2lkdGggPSB7fTsKICAgICAgICAgICAgICAgIGxldCBzdW1NaW5XaWR0aCA9IDA7CiAgICAgICAgICAgICAgICBsZXQgaGFzV2lkdGhDb2x1bW5zID0gW107CiAgICAgICAgICAgICAgICBsZXQgbm9XaWR0aENvbHVtbnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBtYXhXaWR0aENvbHVtbnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBub01heFdpZHRoQ29sdW1ucyA9IFtdOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC53aWR0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBoYXNXaWR0aENvbHVtbnMucHVzaChjb2wpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgICBub1dpZHRoQ29sdW1ucy5wdXNoKGNvbCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wubWluV2lkdGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bU1pbldpZHRoICs9IGNvbC5taW5XaWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sLm1heFdpZHRoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aENvbHVtbnMucHVzaChjb2wpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9NYXhXaWR0aENvbHVtbnMucHVzaChjb2wpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbC5fd2lkdGggPSBudWxsOwogICAgICAgICAgICAgICAgfSk7CgoKICAgICAgICAgICAgICAgIGxldCB1blVzYWJsZVdpZHRoID0gaGFzV2lkdGhDb2x1bW5zLm1hcChjZWxsID0+IGNlbGwud2lkdGgpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApOwogICAgICAgICAgICAgICAgbGV0IHVzYWJsZVdpZHRoID0gdGFibGVXaWR0aCAtIHVuVXNhYmxlV2lkdGggLSBzdW1NaW5XaWR0aCAtICh0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjApIC0gMTsKICAgICAgICAgICAgICAgIGxldCB1c2FibGVMZW5ndGggPSBub1dpZHRoQ29sdW1ucy5sZW5ndGg7CiAgICAgICAgICAgICAgICBsZXQgY29sdW1uV2lkdGggPSAwOwogICAgICAgICAgICAgICAgaWYodXNhYmxlV2lkdGggPiAwICYmIHVzYWJsZUxlbmd0aCA+IDApewogICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoID0gcGFyc2VJbnQodXNhYmxlV2lkdGggLyB1c2FibGVMZW5ndGgpOwogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2xvbmVDb2x1bW5zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jbG9uZUNvbHVtbnNbaV07CiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gY29sdW1uV2lkdGggKyAoY29sdW1uLm1pbldpZHRoP2NvbHVtbi5taW5XaWR0aDowKTsKICAgICAgICAgICAgICAgICAgICBpZihjb2x1bW4ud2lkdGgpewogICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbi53aWR0aDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5fd2lkdGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29sdW1uLl93aWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ubWluV2lkdGggPiB3aWR0aCl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjb2x1bW4ubWluV2lkdGg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2x1bW4ubWF4V2lkdGggPCB3aWR0aCl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjb2x1bW4ubWF4V2lkdGg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWJsZVdpZHRoPjApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2FibGVXaWR0aCAtPSB3aWR0aCAtIChjb2x1bW4ubWluV2lkdGg/Y29sdW1uLm1pbldpZHRoOjApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWJsZUxlbmd0aC0tOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2FibGVMZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoID0gcGFyc2VJbnQodXNhYmxlV2lkdGggLyB1c2FibGVMZW5ndGgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX3dpZHRoID0gd2lkdGg7CgogICAgICAgICAgICAgICAgICAgIGNvbHVtbnNXaWR0aFtjb2x1bW4uX2luZGV4XSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoCiAgICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZih1c2FibGVXaWR0aD4wKSB7CiAgICAgICAgICAgICAgICAgICAgdXNhYmxlTGVuZ3RoID0gbm9NYXhXaWR0aENvbHVtbnMubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoID0gcGFyc2VJbnQodXNhYmxlV2lkdGggLyB1c2FibGVMZW5ndGgpOwogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9NYXhXaWR0aENvbHVtbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gbm9NYXhXaWR0aENvbHVtbnNbaV07CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGNvbHVtbi5fd2lkdGggKyBjb2x1bW5XaWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWJsZUxlbmd0aCA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWJsZUxlbmd0aC0tOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNhYmxlV2lkdGggLT0gY29sdW1uV2lkdGg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aCA9IHBhcnNlSW50KHVzYWJsZVdpZHRoIC8gdXNhYmxlTGVuZ3RoKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLl93aWR0aCA9IHdpZHRoOwoKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1dpZHRoW2NvbHVtbi5faW5kZXhdID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoCiAgICAgICAgICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlV2lkdGggPSB0aGlzLmNsb25lQ29sdW1ucy5tYXAoY2VsbCA9PiBjZWxsLl93aWR0aCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgKyAodGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXI/dGhpcy5zY3JvbGxCYXJXaWR0aDowKSArIDE7CiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnNXaWR0aCA9IGNvbHVtbnNXaWR0aDsKICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRIZWFkZXIoKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlTW91c2VJbiAoX2luZGV4LCByb3dLZXkpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkSG92ZXIpIHJldHVybjsKICAgICAgICAgICAgICAgIGNvbnN0IG9iakRhdGEgPSByb3dLZXkgPyB0aGlzLmdldERhdGFCeVJvd0tleShyb3dLZXkpIDogdGhpcy5vYmpEYXRhW19pbmRleF07CiAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5faXNIb3ZlcikgcmV0dXJuOwogICAgICAgICAgICAgICAgb2JqRGF0YS5faXNIb3ZlciA9IHRydWU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZU1vdXNlT3V0IChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRIb3ZlcikgcmV0dXJuOwogICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHJvd0tleSA/IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSkgOiB0aGlzLm9iakRhdGFbX2luZGV4XTsKICAgICAgICAgICAgICAgIG9iakRhdGEuX2lzSG92ZXIgPSBmYWxzZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8g6YCa55So5aSE55CGIGhpZ2hsaWdodEN1cnJlbnRSb3cg5ZKMIGNsZWFyQ3VycmVudFJvdwogICAgICAgICAgICBoYW5kbGVDdXJyZW50Um93ICh0eXBlLCBfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHJvd0tleSA/IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSkgOiB0aGlzLm9iakRhdGFbX2luZGV4XTsKCiAgICAgICAgICAgICAgICBsZXQgb2xkRGF0YSA9IG51bGw7CiAgICAgICAgICAgICAgICBsZXQgb2xkSW5kZXggPSAtMTsKCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMub2JqRGF0YSkgewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iakRhdGFbaV0uX2lzSGlnaGxpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEluZGV4ID0gcGFyc2VJbnQoaSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqRGF0YVtpXS5faXNIaWdobGlnaHQgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9iakRhdGFbaV0uY2hpbGRyZW4gJiYgdGhpcy5vYmpEYXRhW2ldLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNldERhdGEgPSB0aGlzLmhhbmRsZVJlc2V0Q2hpbGRyZW5Sb3codGhpcy5vYmpEYXRhW2ldKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2V0RGF0YSkgb2xkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzZXREYXRhKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoaWdobGlnaHQnKSBvYmpEYXRhLl9pc0hpZ2hsaWdodCA9IHRydWU7CiAgICAgICAgICAgICAgICBpZiAob2xkSW5kZXggPj0gMCkgewogICAgICAgICAgICAgICAgICAgIG9sZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuY2xvbmVEYXRhW29sZEluZGV4XSkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHR5cGUgPT09ICdoaWdobGlnaHQnID8gcm93S2V5ID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdldEJhc2VEYXRhQnlSb3dLZXkocm93S2V5KSkpIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmNsb25lRGF0YVtfaW5kZXhdKSkgOiBudWxsOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tY3VycmVudC1jaGFuZ2UnLCBuZXdEYXRhLCBvbGREYXRhKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlUmVzZXRDaGlsZHJlblJvdyAob2JqRGF0YSkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsOwogICAgICAgICAgICAgICAgaWYgKG9iakRhdGEuY2hpbGRyZW4gJiYgb2JqRGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iakRhdGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG9iakRhdGEuY2hpbGRyZW5baV07CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLl9pc0hpZ2hsaWdodCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5faXNIaWdobGlnaHQgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuaGFuZGxlUmVzZXRDaGlsZHJlblJvdyhpdGVtKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoaWdobGlnaHRDdXJyZW50Um93IChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHJvd0tleSA/IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSkgOiB0aGlzLm9iakRhdGFbX2luZGV4XTsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5oaWdobGlnaHRSb3cgfHwgb2JqRGF0YS5faXNIaWdobGlnaHQpIHJldHVybjsKICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ3VycmVudFJvdygnaGlnaGxpZ2h0JywgX2luZGV4LCByb3dLZXkpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBjbGVhckN1cnJlbnRSb3cgKCkgewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodFJvdykgcmV0dXJuOwogICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Um93KCdjbGVhcicpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBjbGlja0N1cnJlbnRSb3cgKF9pbmRleCwgcm93S2V5KSB7CiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEN1cnJlbnRSb3cgKF9pbmRleCwgcm93S2V5KTsKICAgICAgICAgICAgICAgIGlmIChyb3dLZXkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1yb3ctY2xpY2snLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0QmFzZURhdGFCeVJvd0tleShyb3dLZXkpKSkpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1yb3ctY2xpY2snLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuY2xvbmVEYXRhW19pbmRleF0pKSwgX2luZGV4KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGJsY2xpY2tDdXJyZW50Um93IChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDdXJyZW50Um93IChfaW5kZXgsIHJvd0tleSk7CiAgICAgICAgICAgICAgICBpZiAocm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tcm93LWRibGNsaWNrJywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdldEJhc2VEYXRhQnlSb3dLZXkocm93S2V5KSkpKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tcm93LWRibGNsaWNrJywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmNsb25lRGF0YVtfaW5kZXhdKSksIF9pbmRleCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNvbnRleHRtZW51Q3VycmVudFJvdyAoX2luZGV4LCByb3dLZXksIGV2ZW50KSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0TWVudVZpc2libGUpIHRoaXMuaGFuZGxlQ2xpY2tDb250ZXh0TWVudU91dHNpZGUoKTsKICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgICAgICAgICBjb25zdCAkVGFibGVXcmFwID0gdGhpcy4kcmVmcy50YWJsZVdyYXA7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgVGFibGVCb3VuZGluZyA9ICRUYWJsZVdyYXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGAke2V2ZW50LmNsaWVudFggLSBUYWJsZUJvdW5kaW5nLmxlZnR9cHhgLAogICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGAke2V2ZW50LmNsaWVudFkgLSBUYWJsZUJvdW5kaW5nLnRvcH1weGAKICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVTdHlsZXMgPSBwb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51VmlzaWJsZSA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1jb250ZXh0bWVudScsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRCYXNlRGF0YUJ5Um93S2V5KHJvd0tleSkpKSwgZXZlbnQsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1jb250ZXh0bWVudScsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbX2luZGV4XSkpLCBldmVudCwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRTZWxlY3Rpb24gKCkgewogICAgICAgICAgICAgICAgLy8g5YiG5Yir5ou/5qC55pWw5o2u5ZKM5a2Q5pWw5o2u55qE5bey6YCJ6aG5CiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uSW5kZXhlcyA9IFtdOwogICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvblJvd0tleXMgPSBbXTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHRoaXMub2JqRGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5faXNDaGVja2VkKSBzZWxlY3Rpb25JbmRleGVzLnB1c2gocGFyc2VJbnQoaSkpOwogICAgICAgICAgICAgICAgICAgIGlmIChvYmpEYXRhLmNoaWxkcmVuICYmIG9iakRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJvd0tleXMgPSBzZWxlY3Rpb25Sb3dLZXlzLmNvbmNhdCh0aGlzLmdldFNlbGVjdGlvbkNoaWxkcmVuUm93S2V5cyhvYmpEYXRhLCBzZWxlY3Rpb25Sb3dLZXlzKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIC8vIOWOu+mHjeeahCBSb3dLZXlzCiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Sb3dLZXlzID0gWy4uLm5ldyBTZXQoc2VsZWN0aW9uUm93S2V5cyldOwoKICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBbXTsKCiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uSW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQoaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoICYmIHNlbGVjdGlvblJvd0tleXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlbihpdGVtLCBzZWxlY3Rpb24sIHNlbGVjdGlvblJvd0tleXMpKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKCgogICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gWy4uLm5ldyBTZXQoc2VsZWN0aW9uKV07CiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZWxlY3Rpb24pKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0U2VsZWN0aW9uQ2hpbGRyZW5Sb3dLZXlzIChvYmpEYXRhLCBzZWxlY3Rpb25Sb3dLZXlzKSB7CiAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5jaGlsZHJlbiAmJiBvYmpEYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIG9iakRhdGEuY2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2lzQ2hlY2tlZCkgc2VsZWN0aW9uUm93S2V5cy5wdXNoKGl0ZW0uX3Jvd0tleSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Sb3dLZXlzID0gc2VsZWN0aW9uUm93S2V5cy5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlblJvd0tleXMoaXRlbSwgc2VsZWN0aW9uUm93S2V5cykpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uUm93S2V5czsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0U2VsZWN0aW9uQ2hpbGRyZW4gKGRhdGEsIHNlbGVjdGlvbiwgc2VsZWN0aW9uUm93S2V5cykgewogICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hpbGRyZW4gJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBkYXRhLmNoaWxkcmVuLmZvckVhY2goaXRlbSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Sb3dLZXlzLmluZGV4T2YoaXRlbVt0aGlzLnJvd0tleV0pID4gLTEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQoaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlbihpdGVtLCBzZWxlY3Rpb24sIHNlbGVjdGlvblJvd0tleXMpKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9nZ2xlU2VsZWN0IChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTsKCiAgICAgICAgICAgICAgICBpZiAocm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChpKSA9PT0gX2luZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5vYmpEYXRhW2ldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSAhZGF0YS5faXNDaGVja2VkOwoKICAgICAgICAgICAgICAgIGRhdGEuX2lzQ2hlY2tlZCA9IHN0YXR1czsKICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7CiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZERhdGEgPSByb3dLZXkgPyB0aGlzLmdldEJhc2VEYXRhQnlSb3dLZXkocm93S2V5LCB0aGlzLmRhdGEpIDogdGhpcy5kYXRhW19pbmRleF07CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KHN0YXR1cyA/ICdvbi1zZWxlY3QnIDogJ29uLXNlbGVjdC1jYW5jZWwnLCBzZWxlY3Rpb24sIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWREYXRhKSkpOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tc2VsZWN0aW9uLWNoYW5nZScsIHNlbGVjdGlvbik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvZ2dsZUV4cGFuZCAoX2luZGV4KSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHt9OwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KGkpID09PSBfaW5kZXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMub2JqRGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gIWRhdGEuX2lzRXhwYW5kZWQ7CiAgICAgICAgICAgICAgICB0aGlzLm9iakRhdGFbX2luZGV4XS5faXNFeHBhbmRlZCA9IHN0YXR1czsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLWV4cGFuZCcsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbX2luZGV4XSkpLCBzdGF0dXMpOwoKICAgICAgICAgICAgICAgIGlmKHRoaXMuaGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KXsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKT0+dGhpcy5maXhlZEJvZHkoKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvZ2dsZVRyZWUgKHJvd0tleSkgewogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICAvLyBhc3luYyBsb2FkaW5nCiAgICAgICAgICAgICAgICBpZiAoJ19sb2FkaW5nJyBpbiBkYXRhICYmIGRhdGEuX2xvYWRpbmcpIHJldHVybjsKICAgICAgICAgICAgICAgIGlmICgnX2xvYWRpbmcnIGluIGRhdGEgJiYgIWRhdGEuX2xvYWRpbmcgJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5nZXRCYXNlRGF0YUJ5Um93S2V5KHJvd0tleSwgdGhpcy5kYXRhKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoc291cmNlRGF0YSwgJ19sb2FkaW5nJywgdHJ1ZSk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRGF0YShzb3VyY2VEYXRhLCBjaGlsZHJlbiA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChzb3VyY2VEYXRhLCAnX2xvYWRpbmcnLCBmYWxzZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChzb3VyY2VEYXRhLCAnY2hpbGRyZW4nLCBjaGlsZHJlbik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YS5faXNTaG93Q2hpbGRyZW4gPSAhbmV3RGF0YS5faXNTaG93Q2hpbGRyZW47CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55Sx5LqOIHVwZGF0ZURhdGFTdGF0dXMg5piv5Z+65LqO5Y6f5pWw5o2u5L+u5pS577yM5a+86Ie05Y2V6YCJ44CB5aSa6YCJ562J54q25oCB6YeN572u77yM5omA5Lul5pqC5LiN5aSE55CGIF9zaG93Q2hpbGRyZW4g54q25oCB77yM6ICM5piv6YCa6L+H5LqL5Lu2IEBvbi1leHBhbmQtdHJlZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOW8guatpeaXtu+8jOmcgOiuvue9riBfc2hvd0NoaWxkcmVu77yM5ZCm5YiZ5bWM5aWX5a2Q6ZuG5bGV5byA77yM5Lya6Ieq5Yqo5pS26LW354i257qnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhU3RhdHVzKHJvd0tleSwgJ19zaG93Q2hpbGRyZW4nLCBuZXdEYXRhLl9pc1Nob3dDaGlsZHJlbik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBkYXRhLl9pc1Nob3dDaGlsZHJlbiA9ICFkYXRhLl9pc1Nob3dDaGlsZHJlbjsKICAgICAgICAgICAgICAgIC8vIOeUseS6jiB1cGRhdGVEYXRhU3RhdHVzIOaYr+WfuuS6juWOn+aVsOaNruS/ruaUue+8jOWvvOiHtOWNlemAieOAgeWkmumAieetieeKtuaAgemHjee9ru+8jOaJgOS7peaaguS4jeWkhOeQhiBfc2hvd0NoaWxkcmVuIOeKtuaAge+8jOiAjOaYr+mAmui/h+S6i+S7tiBAb24tZXhwYW5kLXRyZWUKICAgICAgICAgICAgICAgIC8vICM2NzXvvIzlop7liqAgdXBkYXRlU2hvd0NoaWxkcmVuCiAgICAgICAgICAgICAgICBpZiAodGhpcy51cGRhdGVTaG93Q2hpbGRyZW4pIHRoaXMudXBkYXRlRGF0YVN0YXR1cyhyb3dLZXksICdfc2hvd0NoaWxkcmVuJywgZGF0YS5faXNTaG93Q2hpbGRyZW4pOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tZXhwYW5kLXRyZWUnLCByb3dLZXksIGRhdGEuX2lzU2hvd0NoaWxkcmVuKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiDlvZPkv67mlLnmn5DlhoXnva7lsZ7mgKfvvIzlpoIgX2lzU2hvd0NoaWxkcmVuIOaXtu+8jOWboOW9k+WwhuWOnyBkYXRhIOWvueW6lCBfc2hvd0NoaWxkcmVuIOS5n+S/ruaUue+8jOWQpuWImeS/ruaUuSBkYXRhIOaXtu+8jOeKtuaAgeS8mumHjee9rgogICAgICAgICAgICAgKiBAcGFyYW0gcm93S2V5IHJvd0tleQogICAgICAgICAgICAgKiBAcGFyYW0ga2V5IOWOn+aVsOaNruWvueW6lOeahOWtl+autQogICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUg5L+u5pS555qE5YC8CiAgICAgICAgICAgICAqICovCiAgICAgICAgICAgIC8vIHRvZG8g5Y2V6YCJ44CB5aSa6YCJ562J54q25oCB5Y+v6IO95Lmf6ZyA6KaB5pu05paw5Y6f5pWw5o2uCiAgICAgICAgICAgIHVwZGF0ZURhdGFTdGF0dXMgKHJvd0tleSwga2V5LCB2YWx1ZSkgewogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QmFzZURhdGFCeVJvd0tleShyb3dLZXksIHRoaXMuZGF0YSk7CiAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZGF0YSwga2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGdldERhdGFCeVJvd0tleSAocm93S2V5LCBvYmpEYXRhID0gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIG9iakRhdGEpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzRGF0YSA9IG9iakRhdGFbaV07CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNEYXRhLl9yb3dLZXkgPT09IHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpc0RhdGE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc0RhdGEuY2hpbGRyZW4gJiYgdGhpc0RhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldENoaWxkcmVuQnlSb3dLZXkocm93S2V5LCB0aGlzRGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRDaGlsZHJlbkJ5Um93S2V5IChyb3dLZXksIG9iakRhdGEpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDsKICAgICAgICAgICAgICAgIGlmIChvYmpEYXRhLmNoaWxkcmVuICYmIG9iakRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpEYXRhLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvYmpEYXRhLmNoaWxkcmVuW2ldOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5fcm93S2V5ID09PSByb3dLZXkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0Q2hpbGRyZW5CeVJvd0tleShyb3dLZXksIGl0ZW0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRCYXNlRGF0YUJ5Um93S2V5IChyb3dLZXksIHNvdXJjZURhdGEgPSB0aGlzLmNsb25lRGF0YSkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsOwogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VEYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc0RhdGEgPSBzb3VyY2VEYXRhW2ldOwogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzRGF0YVt0aGlzLnJvd0tleV0gPT09IHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpc0RhdGE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc0RhdGEuY2hpbGRyZW4gJiYgdGhpc0RhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldENoaWxkcmVuRGF0YUJ5Um93S2V5KHJvd0tleSwgdGhpc0RhdGEpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW3RoaXMucm93S2V5XSA9PT0gcm93S2V5KSByZXR1cm4gZGF0YTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0Q2hpbGRyZW5EYXRhQnlSb3dLZXkgKHJvd0tleSwgY2xvbmVEYXRhKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7CiAgICAgICAgICAgICAgICBpZiAoY2xvbmVEYXRhLmNoaWxkcmVuICYmIGNsb25lRGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lRGF0YS5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gY2xvbmVEYXRhLmNoaWxkcmVuW2ldOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVt0aGlzLnJvd0tleV0gPT09IHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGl0ZW07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5nZXRDaGlsZHJlbkRhdGFCeVJvd0tleShyb3dLZXksIGl0ZW0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBzZWxlY3RBbGwgKHN0YXR1cykgewogICAgICAgICAgICAgICAgLy8gdGhpcy5yZWJ1aWxkRGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7CiAgICAgICAgICAgICAgICAvLyAgICAgaWYodGhpcy5vYmpEYXRhW2RhdGEuX2luZGV4XS5faXNEaXNhYmxlZCl7CiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMub2JqRGF0YVtkYXRhLl9pbmRleF0uX2lzQ2hlY2tlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgLy8gICAgIH1lbHNlewogICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLm9iakRhdGFbZGF0YS5faW5kZXhdLl9pc0NoZWNrZWQgPSBzdGF0dXM7CiAgICAgICAgICAgICAgICAvLyAgICAgfQoKICAgICAgICAgICAgICAgIC8vIH0pOwogICAgICAgICAgICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRoaXMucmVidWlsZERhdGEpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpEYXRhID0gdGhpcy5vYmpEYXRhW2RhdGEuX2luZGV4XTsKICAgICAgICAgICAgICAgICAgICBpZiAoIW9iakRhdGEuX2lzRGlzYWJsZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgb2JqRGF0YS5faXNDaGVja2VkID0gc3RhdHVzOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaGlsZHJlbiAmJiBkYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEFsbENoaWxkcmVuKG9iakRhdGEsIHN0YXR1cyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTsKICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1zZWxlY3QtYWxsJywgc2VsZWN0aW9uKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tc2VsZWN0LWFsbC1jYW5jZWwnLCBzZWxlY3Rpb24pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tc2VsZWN0aW9uLWNoYW5nZScsIHNlbGVjdGlvbik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNlbGVjdEFsbENoaWxkcmVuIChkYXRhLCBzdGF0dXMpIHsKICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoaWxkcmVuICYmIGRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgZGF0YS5jaGlsZHJlbi5tYXAoaXRlbSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5faXNEaXNhYmxlZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5faXNDaGVja2VkID0gc3RhdHVzOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEFsbENoaWxkcmVuKGl0ZW0sIHN0YXR1cyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZml4ZWRIZWFkZXIgKCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZUhlaWdodCA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuJHJlZnMudGl0bGUsICdoZWlnaHQnKSkgfHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0ID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy4kcmVmcy5oZWFkZXIsICdoZWlnaHQnKSkgfHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9vdGVySGVpZ2h0ID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy4kcmVmcy5mb290ZXIsICdoZWlnaHQnKSkgfHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHRpdGxlSGVpZ2h0IC0gaGVhZGVySGVpZ2h0IC0gZm9vdGVySGVpZ2h0OwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF4SGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHRpdGxlSGVpZ2h0IC0gaGVhZGVySGVpZ2h0IC0gZm9vdGVySGVpZ2h0OwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpPT50aGlzLmZpeGVkQm9keSgpKTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib2R5SGVpZ2h0ID0gMDsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKT0+dGhpcy5maXhlZEJvZHkoKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpeGVkQm9keSAoKXsKICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzLmhlYWRlcikgewogICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyV2lkdGggPSB0aGlzLiRyZWZzLmhlYWRlci5jaGlsZHJlblswXS5vZmZzZXRXaWR0aDsKICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckhlaWdodCA9IHRoaXMuJHJlZnMuaGVhZGVyLmNoaWxkcmVuWzBdLm9mZnNldEhlaWdodDsKICAgICAgICAgICAgICAgICAgICAvL3RoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXIgPSB0aGlzLmhlYWRlcldpZHRoPnRoaXMuJHJlZnMuaGVhZGVyLm9mZnNldFdpZHRoOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmICghdGhpcy4kcmVmcy50Ym9keSB8fCAhdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhciA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZXsKICAgICAgICAgICAgICAgICAgICBsZXQgYm9keUNvbnRlbnRFbCA9IHRoaXMuJHJlZnMudGJvZHkuJGVsOwogICAgICAgICAgICAgICAgICAgIGxldCBib2R5RWwgPSBib2R5Q29udGVudEVsLnBhcmVudEVsZW1lbnQ7CiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHlDb250ZW50SGVpZ2h0ID0gYm9keUNvbnRlbnRFbC5vZmZzZXRIZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHlIZWlnaHQgPSBib2R5RWwub2Zmc2V0SGVpZ2h0OwoKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dIb3Jpem9udGFsU2Nyb2xsQmFyID0gYm9keUVsLm9mZnNldFdpZHRoIDwgYm9keUNvbnRlbnRFbC5vZmZzZXRXaWR0aCArICh0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjApOwogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyID0gdGhpcy5ib2R5SGVpZ2h0PyBib2R5SGVpZ2h0IC0gKHRoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXI/dGhpcy5zY3JvbGxCYXJXaWR0aDowKSA8IGJvZHlDb250ZW50SGVpZ2h0IDogZmFsc2U7CgogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyKXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keUVsLmNsYXNzTGlzdC5hZGQodGhpcy5wcmVmaXhDbHMgKyctb3ZlcmZsb3dZJyk7CiAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlFbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMucHJlZml4Q2xzICsnLW92ZXJmbG93WScpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnNob3dIb3Jpem9udGFsU2Nyb2xsQmFyKXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keUVsLmNsYXNzTGlzdC5hZGQodGhpcy5wcmVmaXhDbHMgKyctb3ZlcmZsb3dYJyk7CiAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlFbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMucHJlZml4Q2xzICsnLW92ZXJmbG93WCcpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIGhpZGVDb2x1bW5GaWx0ZXIgKCkgewogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiBjb2wuX2ZpbHRlclZpc2libGUgPSBmYWxzZSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZUJvZHlTY3JvbGwgKGV2ZW50KSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93SGVhZGVyKSB0aGlzLiRyZWZzLmhlYWRlci5zY3JvbGxMZWZ0ID0gZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQ7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xlZnRGaXhlZCkgdGhpcy4kcmVmcy5maXhlZEJvZHkuc2Nyb2xsVG9wID0gZXZlbnQudGFyZ2V0LnNjcm9sbFRvcDsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmlnaHRGaXhlZCkgdGhpcy4kcmVmcy5maXhlZFJpZ2h0Qm9keS5zY3JvbGxUb3AgPSBldmVudC50YXJnZXQuc2Nyb2xsVG9wOwogICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1N1bW1hcnkgJiYgdGhpcy4kcmVmcy5zdW1tYXJ5KSB0aGlzLiRyZWZzLnN1bW1hcnkuJGVsLnNjcm9sbExlZnQgPSBldmVudC50YXJnZXQuc2Nyb2xsTGVmdDsKICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbHVtbkZpbHRlcigpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVGaXhlZE1vdXNld2hlZWwoZXZlbnQpIHsKICAgICAgICAgICAgICAgIGxldCBkZWx0YVkgPSBldmVudC5kZWx0YVk7CiAgICAgICAgICAgICAgICBpZighZGVsdGFZICYmIGV2ZW50LmRldGFpbCl7CiAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gZXZlbnQuZGV0YWlsICogNDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZighZGVsdGFZICYmIGV2ZW50LndoZWVsRGVsdGFZKXsKICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAtZXZlbnQud2hlZWxEZWx0YVk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZighZGVsdGFZICYmIGV2ZW50LndoZWVsRGVsdGEpewogICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IC1ldmVudC53aGVlbERlbHRhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYoIWRlbHRhWSkgcmV0dXJuOwogICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuJHJlZnMuYm9keTsKICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxUb3AgPSBib2R5LnNjcm9sbFRvcDsKICAgICAgICAgICAgICAgIGlmIChkZWx0YVkgPCAwICYmIGN1cnJlbnRTY3JvbGxUb3AgIT09IDApIHsKICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGRlbHRhWSA+IDAgJiYgYm9keS5zY3JvbGxIZWlnaHQgLSBib2R5LmNsaWVudEhlaWdodCA+IGN1cnJlbnRTY3JvbGxUb3ApIHsKICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgLy9ib2R5LnNjcm9sbFRvcCArPSBkZWx0YVk7CiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IDA7CiAgICAgICAgICAgICAgICBsZXQgdGltZUlkID0gc2V0SW50ZXJ2YWwoKCk9PnsKICAgICAgICAgICAgICAgICAgICBzdGVwICs9IDU7CiAgICAgICAgICAgICAgICAgICAgaWYoZGVsdGFZPjApewogICAgICAgICAgICAgICAgICAgICAgICBib2R5LnNjcm9sbFRvcCArPSAyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgICBib2R5LnNjcm9sbFRvcCAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZihzdGVwID49IE1hdGguYWJzKGRlbHRhWSkpewogICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVJZCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwgNSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZU1vdXNlV2hlZWwgKGV2ZW50KSB7CiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVggPSBldmVudC5kZWx0YVg7CiAgICAgICAgICAgICAgICBjb25zdCAkYm9keSA9IHRoaXMuJHJlZnMuYm9keTsKCiAgICAgICAgICAgICAgICBpZiAoZGVsdGFYID4gMCkgewogICAgICAgICAgICAgICAgICAgICRib2R5LnNjcm9sbExlZnQgPSAkYm9keS5zY3JvbGxMZWZ0ICsgMTA7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICRib2R5LnNjcm9sbExlZnQgPSAkYm9keS5zY3JvbGxMZWZ0IC0gMTA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNvcnREYXRhIChkYXRhLCB0eXBlLCBpbmRleCkgewogICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLmtleTsKICAgICAgICAgICAgICAgIGRhdGEuc29ydCgoYSwgYikgPT4gewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uc29ydE1ldGhvZCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLnNvcnRNZXRob2QoYVtrZXldLCBiW2tleV0sIHR5cGUpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnYXNjJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XSA/IDEgOiAtMTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVzYycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPCBiW2tleV0gPyAxIDogLTE7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLmNoaWxkcmVuICYmIGRhdGFbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0uY2hpbGRyZW4gPSB0aGlzLnNvcnREYXRhKGRhdGFbaV0uY2hpbGRyZW4sIHR5cGUsIGluZGV4KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlU29ydCAoX2luZGV4LCB0eXBlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuR2V0T3JpZ2luYWxJbmRleChfaW5kZXgpOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiBjb2wuX3NvcnRUeXBlID0gJ25vcm1hbCcpOwoKICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5rZXk7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLnNvcnRhYmxlICE9PSAnY3VzdG9tJykgeyAgICAvLyBjdXN0b20gaXMgZm9yIHJlbW90ZSBzb3J0CiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdub3JtYWwnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZERhdGEgPSB0aGlzLm1ha2VEYXRhV2l0aEZpbHRlcigpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZERhdGEgPSB0aGlzLnNvcnREYXRhKHRoaXMucmVidWlsZERhdGEsIHR5cGUsIGluZGV4KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX3NvcnRUeXBlID0gdHlwZTsKCiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1zb3J0LWNoYW5nZScsIHsKICAgICAgICAgICAgICAgICAgICBjb2x1bW46IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5hbGxDb2x1bW5zW3RoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5faW5kZXhdKSksCiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksCiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHR5cGUKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVGaWx0ZXJIaWRlIChpbmRleCkgeyAgICAvLyBjbGVhciBjaGVja2VkIHRoYXQgbm90IGZpbHRlciBub3cKICAgICAgICAgICAgICAgIGlmICghdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9pc0ZpbHRlcmVkKSB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX2ZpbHRlckNoZWNrZWQgPSBbXTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZmlsdGVyRGF0YSAoZGF0YSwgY29sdW1uKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5maWx0ZXIoKHJvdykgPT4gewogICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5a6a5LmJ5LqG6L+c56iL6L+H5ruk5pa55rOV5YiZ5b+955Wl5q2k5pa55rOVCiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4uZmlsdGVyUmVtb3RlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZTsKCiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9ICFjb2x1bW4uX2ZpbHRlckNoZWNrZWQubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uLl9maWx0ZXJDaGVja2VkLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGNvbHVtbi5maWx0ZXJNZXRob2QoY29sdW1uLl9maWx0ZXJDaGVja2VkW2ldLCByb3cpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1czsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaWx0ZXJPdGhlckRhdGEgKGRhdGEsIGluZGV4KSB7CiAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdOwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4uZmlsdGVyUmVtb3RlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmZpbHRlclJlbW90ZS5jYWxsKHRoaXMuJHBhcmVudCwgY29sdW1uLl9maWx0ZXJDaGVja2VkLCBjb2x1bW4ua2V5LCBjb2x1bW4pOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zLmZvckVhY2goKGNvbCwgY29sSW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoY29sSW5kZXggIT09IGluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmZpbHRlckRhdGEoZGF0YSwgY29sKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVGaWx0ZXIgKGluZGV4KSB7CiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF07CiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydCgpOwoKICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdGhlcnMgZmlyc3QsIGFmdGVyIGZpbHRlciB0aGlzIGNvbHVtbgogICAgICAgICAgICAgICAgZmlsdGVyRGF0YSA9IHRoaXMuZmlsdGVyT3RoZXJEYXRhKGZpbHRlckRhdGEsIGluZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZERhdGEgPSB0aGlzLmZpbHRlckRhdGEoZmlsdGVyRGF0YSwgY29sdW1uKTsKCiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX2lzRmlsdGVyZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9maWx0ZXJWaXNpYmxlID0gZmFsc2U7CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1maWx0ZXItY2hhbmdlJywgY29sdW1uKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqICMyODMyCiAgICAgICAgICAgICAqIOW6lOivpeWMuuWIhuW9k+WJjeihqOWktOeahCBjb2x1bW4g5piv5bem5Zu65a6a6L+Y5piv5Y+z5Zu65a6aCiAgICAgICAgICAgICAqIOWQpuWImeaJp+ihjOWIsCAkcGFyZW50IOaXtu+8jOaWueazleeahCBpbmRleCDkuI4gY2xvbmVDb2x1bW5zIOeahCBpbmRleCDmmK/kuI3lr7nlupTnmoQKICAgICAgICAgICAgICog5bem5Zu65a6a5ZKM5Y+z5Zu65a6a77yM6KaB5Yy65YiG5a+55b6FCiAgICAgICAgICAgICAqIOaJgOS7pe+8jOatpOaWueazleeUqOadpeiOt+WPluato+ehrueahCBpbmRleAogICAgICAgICAgICAgKiAqLwogICAgICAgICAgICBHZXRPcmlnaW5hbEluZGV4IChfaW5kZXgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lQ29sdW1ucy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLl9pbmRleCA9PT0gX2luZGV4KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlRmlsdGVyU2VsZWN0IChfaW5kZXgsIHZhbHVlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuR2V0T3JpZ2luYWxJbmRleChfaW5kZXgpOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9maWx0ZXJDaGVja2VkID0gW3ZhbHVlXTsKICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRmlsdGVyKGluZGV4KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlRmlsdGVyUmVzZXQgKF9pbmRleCkgewogICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLkdldE9yaWdpbmFsSW5kZXgoX2luZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5faXNGaWx0ZXJlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9maWx0ZXJWaXNpYmxlID0gZmFsc2U7CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX2ZpbHRlckNoZWNrZWQgPSBbXTsKCiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydCgpOwogICAgICAgICAgICAgICAgZmlsdGVyRGF0YSA9IHRoaXMuZmlsdGVyT3RoZXJEYXRhKGZpbHRlckRhdGEsIGluZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZERhdGEgPSBmaWx0ZXJEYXRhOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tZmlsdGVyLWNoYW5nZScsIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VEYXRhICgpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gZGVlcENvcHkodGhpcy5kYXRhKTsKICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgocm93LCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIHJvdy5faW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICByb3cuX3Jvd0tleSA9ICh0eXBlb2YgdGhpcy5yb3dLZXkpID09PSAnc3RyaW5nJyA/IHJvd1t0aGlzLnJvd0tleV0gOiByb3dLZXkrKzsKICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNoaWxkcmVuICYmIHJvdy5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcm93LmNoaWxkcmVuID0gdGhpcy5tYWtlQ2hpbGRyZW5EYXRhKHJvdyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZUNoaWxkcmVuRGF0YSAoZGF0YSkgewogICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hpbGRyZW4gJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jaGlsZHJlbi5tYXAoKHJvdywgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Um93ID0gZGVlcENvcHkocm93KTsKICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pbmRleCA9IGluZGV4OwogICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX3Jvd0tleSA9ICh0eXBlb2YgdGhpcy5yb3dLZXkpID09PSAnc3RyaW5nJyA/IG5ld1Jvd1t0aGlzLnJvd0tleV0gOiByb3dLZXkrKzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5jaGlsZHJlbiAmJiBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuY2hpbGRyZW4gPSB0aGlzLm1ha2VDaGlsZHJlbkRhdGEobmV3Um93KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Um93OwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZURhdGFXaXRoU29ydCAoKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMubWFrZURhdGEoKTsKICAgICAgICAgICAgICAgIGxldCBzb3J0VHlwZSA9ICdub3JtYWwnOwogICAgICAgICAgICAgICAgbGV0IHNvcnRJbmRleCA9IC0xOwogICAgICAgICAgICAgICAgbGV0IGlzQ3VzdG9tID0gZmFsc2U7CgogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNsb25lQ29sdW1ucy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb25lQ29sdW1uc1tpXS5fc29ydFR5cGUgIT09ICdub3JtYWwnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRUeXBlID0gdGhpcy5jbG9uZUNvbHVtbnNbaV0uX3NvcnRUeXBlOwogICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5kZXggPSBpOwogICAgICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbSA9IHRoaXMuY2xvbmVDb2x1bW5zW2ldLnNvcnRhYmxlID09PSAnY3VzdG9tJzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHNvcnRUeXBlICE9PSAnbm9ybWFsJyAmJiAhaXNDdXN0b20pIGRhdGEgPSAgdGhpcy5zb3J0RGF0YShkYXRhLCBzb3J0VHlwZSwgc29ydEluZGV4KTsKICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYWtlRGF0YVdpdGhGaWx0ZXIgKCkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLm1ha2VEYXRhKCk7CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKGNvbCA9PiBkYXRhID0gdGhpcy5maWx0ZXJEYXRhKGRhdGEsIGNvbCkpOwogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VEYXRhV2l0aFNvcnRBbmRGaWx0ZXIgKCkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLm1ha2VEYXRhV2l0aFNvcnQoKTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zLmZvckVhY2goY29sID0+IGRhdGEgPSB0aGlzLmZpbHRlckRhdGEoZGF0YSwgY29sKSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZU9iakJhc2VEYXRhIChyb3cpIHsKICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGRlZXBDb3B5KHJvdyk7CiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB0aGlzLnJvd0tleSkgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9yb3dLZXkgPSBuZXdSb3dbdGhpcy5yb3dLZXldOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbmV3Um93Ll9pc0hvdmVyID0gZmFsc2U7CiAgICAgICAgICAgICAgICBpZiAobmV3Um93Ll9kaXNhYmxlZCkgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNEaXNhYmxlZCA9IG5ld1Jvdy5fZGlzYWJsZWQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNEaXNhYmxlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5fY2hlY2tlZCkgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNDaGVja2VkID0gbmV3Um93Ll9jaGVja2VkOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzQ2hlY2tlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5fZXhwYW5kZWQpIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzRXhwYW5kZWQgPSBuZXdSb3cuX2V4cGFuZGVkOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzRXhwYW5kZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChuZXdSb3cuX2hpZ2hsaWdodCkgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNIaWdobGlnaHQgPSBuZXdSb3cuX2hpZ2hsaWdodDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc0hpZ2hsaWdodCA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdzsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZU9iakRhdGEgKCkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTsKICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKChyb3csIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Um93ID0gdGhpcy5tYWtlT2JqQmFzZURhdGEocm93KTsKICAgICAgICAgICAgICAgICAgICBpZiAobmV3Um93LmNoaWxkcmVuICYmIG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5fc2hvd0NoaWxkcmVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzU2hvd0NoaWxkcmVuID0gbmV3Um93Ll9zaG93Q2hpbGRyZW47CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzU2hvd0NoaWxkcmVuID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93LmNoaWxkcmVuID0gdGhpcy5tYWtlQ2hpbGRyZW5PYmpEYXRhKG5ld1Jvdyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgKCdfbG9hZGluZycgaW4gbmV3Um93ICYmIG5ld1Jvdy5jaGlsZHJlbiAmJiBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gICAgIG5ld1Jvdy5faXNTaG93Q2hpbGRyZW4gPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBuZXdSb3c7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYWtlQ2hpbGRyZW5PYmpEYXRhIChkYXRhKSB7CiAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaGlsZHJlbiAmJiBkYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmNoaWxkcmVuLm1hcChyb3cgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSb3cgPSB0aGlzLm1ha2VPYmpCYXNlRGF0YShyb3cpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Um93Ll9zaG93Q2hpbGRyZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNTaG93Q2hpbGRyZW4gPSBuZXdSb3cuX3Nob3dDaGlsZHJlbjsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNTaG93Q2hpbGRyZW4gPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Um93LmNoaWxkcmVuICYmIG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5jaGlsZHJlbiA9IHRoaXMubWFrZUNoaWxkcmVuT2JqRGF0YShuZXdSb3cpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3c7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyDkv67mlLnliJfvvIzorr7nva7kuIDkuKrpmpDol4/nmoQgaWTvvIzkvr/kuo7lkI7pnaLnmoTlpJrnuqfooajlpLTlr7vmib7lr7nlupTnmoTliJfvvIzlkKbliJnmib7kuI3liLAKICAgICAgICAgICAgbWFrZUNvbHVtbnNJZCAoY29sdW1ucykgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGl0ZW0gPT4gewogICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRyZW4nIGluIGl0ZW0pIHRoaXMubWFrZUNvbHVtbnNJZChpdGVtLmNoaWxkcmVuKTsKICAgICAgICAgICAgICAgICAgICBpdGVtLl9faWQgPSBnZXRSYW5kb21TdHIoNik7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZUNvbHVtbnMgKGNvbHMpIHsKICAgICAgICAgICAgICAgIC8vIOWcqCBkYXRhIOaXtu+8jHRoaXMuYWxsQ29sdW1ucyDmmoLml7bkuLogdW5kZWZpbmVkCiAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9IGRlZXBDb3B5KGdldEFsbENvbHVtbnMoY29scykpOwogICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBbXTsKICAgICAgICAgICAgICAgIGxldCByaWdodCA9IFtdOwogICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IFtdOwoKICAgICAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5faW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX2NvbHVtbktleSA9IGNvbHVtbktleSsrOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IHBhcnNlSW50KGNvbHVtbi53aWR0aCk7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl93aWR0aCA9IGNvbHVtbi53aWR0aCA/IGNvbHVtbi53aWR0aCA6ICcnOyAgICAvLyB1cGRhdGUgaW4gaGFuZGxlUmVzaXplKCkKICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX3NvcnRUeXBlID0gJ25vcm1hbCc7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9maWx0ZXJWaXNpYmxlID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9pc0ZpbHRlcmVkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9maWx0ZXJDaGVja2VkID0gW107CgogICAgICAgICAgICAgICAgICAgIGlmICgnZmlsdGVyTXVsdGlwbGUnIGluIGNvbHVtbikgewogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX2ZpbHRlck11bHRpcGxlID0gY29sdW1uLmZpbHRlck11bHRpcGxlOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5fZmlsdGVyTXVsdGlwbGUgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoJ2ZpbHRlcmVkVmFsdWUnIGluIGNvbHVtbikgewogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX2ZpbHRlckNoZWNrZWQgPSBjb2x1bW4uZmlsdGVyZWRWYWx1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9pc0ZpbHRlcmVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmICgnc29ydFR5cGUnIGluIGNvbHVtbikgewogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX3NvcnRUeXBlID0gY29sdW1uLnNvcnRUeXBlOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5maXhlZCAmJiBjb2x1bW4uZml4ZWQgPT09ICdsZWZ0JykgewogICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnB1c2goY29sdW1uKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbi5maXhlZCAmJiBjb2x1bW4uZml4ZWQgPT09ICdyaWdodCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQucHVzaChjb2x1bW4pOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlci5wdXNoKGNvbHVtbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC5jb25jYXQoY2VudGVyKS5jb25jYXQocmlnaHQpOwogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBjcmVhdGUgYSBtdWx0aXBsZSB0YWJsZS1oZWFkCiAgICAgICAgICAgIG1ha2VDb2x1bW5Sb3dzIChmaXhlZFR5cGUsIGNvbHMpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9Sb3dzKGNvbHMsIGZpeGVkVHlwZSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGV4cG9ydENzdiAocGFyYW1zKSB7CiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbGVuYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWxlbmFtZS5pbmRleE9mKCcuY3N2JykgPT09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlbmFtZSArPSAnLmNzdic7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsZW5hbWUgPSAndGFibGUuY3N2JzsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9IFtdOwogICAgICAgICAgICAgICAgbGV0IGRhdGFzID0gW107CiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNvbHVtbnMgJiYgcGFyYW1zLmRhdGEpIHsKICAgICAgICAgICAgICAgICAgICBjb2x1bW5zID0gcGFyYW1zLmNvbHVtbnM7CiAgICAgICAgICAgICAgICAgICAgZGF0YXMgPSBwYXJhbXMuZGF0YTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyA9IHRoaXMuYWxsQ29sdW1uczsKICAgICAgICAgICAgICAgICAgICBpZiAoISgnb3JpZ2luYWwnIGluIHBhcmFtcykpIHBhcmFtcy5vcmlnaW5hbCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgZGF0YXMgPSBwYXJhbXMub3JpZ2luYWwgPyB0aGlzLmRhdGEgOiB0aGlzLnJlYnVpbGREYXRhOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGxldCBub0hlYWRlciA9IGZhbHNlOwogICAgICAgICAgICAgICAgaWYgKCdub0hlYWRlcicgaW4gcGFyYW1zKSBub0hlYWRlciA9IHBhcmFtcy5ub0hlYWRlcjsKCiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gQ3N2KGNvbHVtbnMsIGRhdGFzLCBwYXJhbXMsIG5vSGVhZGVyKTsKICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2FsbGJhY2spIHBhcmFtcy5jYWxsYmFjayhkYXRhKTsKICAgICAgICAgICAgICAgIGVsc2UgRXhwb3J0Q3N2LmRvd25sb2FkKHBhcmFtcy5maWxlbmFtZSwgZGF0YSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGRyYWdBbmREcm9wKGEsYikgewogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tZHJhZy1kcm9wJywgYSxiKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlQ2xpY2tDb250ZXh0TWVudU91dHNpZGUgKCkgewogICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudVZpc2libGUgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgY3JlYXRlZCAoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aGlzLmN1cnJlbnRDb250ZXh0ID0gdGhpcy4kcGFyZW50OwogICAgICAgICAgICB0aGlzLnNob3dTbG90SGVhZGVyID0gdGhpcy4kc2xvdHMuaGVhZGVyICE9PSB1bmRlZmluZWQ7CiAgICAgICAgICAgIHRoaXMuc2hvd1Nsb3RGb290ZXIgPSB0aGlzLiRzbG90cy5mb290ZXIgIT09IHVuZGVmaW5lZDsKICAgICAgICAgICAgdGhpcy5yZWJ1aWxkRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydEFuZEZpbHRlcigpOwogICAgICAgIH0sCiAgICAgICAgbW91bnRlZCAoKSB7CiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVhZHkgPSB0cnVlKTsKCiAgICAgICAgICAgIG9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTsKICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyKCk7CiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIubGlzdGVuVG8odGhpcy4kZWwsIHRoaXMuaGFuZGxlUmVzaXplKTsKCiAgICAgICAgICAgIHRoaXMuJG9uKCdvbi12aXNpYmxlLWNoYW5nZScsICh2YWwpID0+IHsKICAgICAgICAgICAgICAgIGlmICh2YWwpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgYmVmb3JlRGVzdHJveSAoKSB7CiAgICAgICAgICAgIHRoaXMuJG9mZignb24tdmlzaWJsZS1jaGFuZ2UnKTsKICAgICAgICAgICAgb2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTsKICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnModGhpcy4kZWwpOwogICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVuaW5zdGFsbCh0aGlzLiRlbCk7CiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsOwogICAgICAgIH0sCiAgICAgICAgd2F0Y2g6IHsKICAgICAgICAgICAgZGF0YTogewogICAgICAgICAgICAgICAgaGFuZGxlciAoKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkRGF0YUxlbiA9IHRoaXMucmVidWlsZERhdGEubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgIHRoaXMub2JqRGF0YSA9IHRoaXMubWFrZU9iakRhdGEoKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gdGhpcy5tYWtlRGF0YVdpdGhTb3J0QW5kRmlsdGVyKCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZERhdGFMZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZEhlYWRlcigpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdpbGwgdHJpZ2dlciBiZWZvcmUgY2xpY2tDdXJyZW50Um93LCBzbyB1c2UgYXN5bmMKICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9uZURhdGEgPSBkZWVwQ29weSh0aGlzLmRhdGEpOwogICAgICAgICAgICAgICAgICAgIH0sIDApOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGRlZXA6IHRydWUKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY29sdW1uczogewogICAgICAgICAgICAgICAgaGFuZGxlciAoKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbyDov5nph4zmnInmgKfog73pl67popjvvIzlj6/og73mmK/lt6blj7Plm7rlrprorqHnrpflsZ7mgKflvbHlk43nmoQKICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xzV2l0aElkID0gdGhpcy5tYWtlQ29sdW1uc0lkKHRoaXMuY29sdW1ucyk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gZ2V0QWxsQ29sdW1ucyhjb2xzV2l0aElkKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucyA9IHRoaXMubWFrZUNvbHVtbnMoY29sc1dpdGhJZCk7CgogICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uUm93cyA9IHRoaXMubWFrZUNvbHVtblJvd3MoZmFsc2UsIGNvbHNXaXRoSWQpOwogICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdEZpeGVkQ29sdW1uUm93cyA9IHRoaXMubWFrZUNvbHVtblJvd3MoJ2xlZnQnLCBjb2xzV2l0aElkKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Rml4ZWRDb2x1bW5Sb3dzID0gdGhpcy5tYWtlQ29sdW1uUm93cygncmlnaHQnLCBjb2xzV2l0aElkKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gdGhpcy5tYWtlRGF0YVdpdGhTb3J0QW5kRmlsdGVyKCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBkZWVwOiB0cnVlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhlaWdodCAoKSB7CiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYXhIZWlnaHQgKCkgewogICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc2hvd0hvcml6b250YWxTY3JvbGxCYXIgKCkgewogICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyICgpIHsKICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9Owo="},{"version":3,"sources":["table.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"table.vue","sourceRoot":"node_modules/view-design/src/components/table","sourcesContent":["<template>\n    <div :class=\"wrapClasses\" :style=\"styles\" ref=\"tableWrap\">\n        <div :class=\"classes\">\n            <div :class=\"[prefixCls + '-title']\" v-if=\"showSlotHeader\" ref=\"title\"><slot name=\"header\"></slot></div>\n            <div :class=\"[prefixCls + '-header']\" v-if=\"showHeader\" ref=\"header\" @mousewheel=\"handleMouseWheel\">\n                <table-head\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"tableHeaderStyle\"\n                    :columns=\"cloneColumns\"\n                    :column-rows=\"columnRows\"\n                    :obj-data=\"objData\"\n                    :columns-width=\"columnsWidth\"\n                    :data=\"rebuildData\"></table-head>\n            </div>\n            <div :class=\"[prefixCls + '-body']\" :style=\"bodyStyle\" ref=\"body\" @scroll=\"handleBodyScroll\"\n                v-show=\"!((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\n                <table-body\n                    ref=\"tbody\"\n                    :draggable=\"draggable\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"tableStyle\"\n                    :columns=\"cloneColumns\"\n                    :data=\"rebuildData\"\n                    :row-key=\"rowKey\"\n                    :columns-width=\"columnsWidth\"\n                    :obj-data=\"objData\"></table-body>\n            </div>\n            <table-summary\n                v-if=\"showSummary && (data && data.length)\"\n                ref=\"summary\"\n                :prefix-cls=\"prefixCls\"\n                :styleObject=\"tableStyle\"\n                :columns=\"cloneColumns\"\n                :data=\"summaryData\"\n                :columns-width=\"columnsWidth\"\n            />\n            <div\n                :class=\"[prefixCls + '-tip']\" :style=\"bodyStyle\" @scroll=\"handleBodyScroll\"\n                v-show=\"((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\n                <table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n                    <tbody>\n                        <tr>\n                            <td :style=\"{'height':bodyStyle.height,'width':`${this.headerWidth}px`}\">\n                                <span v-html=\"localeNoDataText\" v-if=\"!data || data.length === 0\"></span>\n                                <span v-html=\"localeNoFilteredDataText\" v-else></span>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div :class=\"[prefixCls + '-fixed']\" :style=\"fixedTableStyle\" v-if=\"isLeftFixed\">\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\n                    <table-head\n                        fixed=\"left\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedTableStyle\"\n                        :columns=\"leftFixedColumns\"\n                        :column-rows=\"columnRows\"\n                        :fixed-column-rows=\"leftFixedColumnRows\"\n                        :obj-data=\"objData\"\n                        :columns-width=\"columnsWidth\"\n                        :data=\"rebuildData\"></table-head>\n                </div>\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedBody\" @mousewheel=\"handleFixedMousewheel\" @DOMMouseScroll=\"handleFixedMousewheel\">\n                    <table-body\n                        fixed=\"left\"\n                        :draggable=\"draggable\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedTableStyle\"\n                        :columns=\"leftFixedColumns\"\n                        :data=\"rebuildData\"\n                        :row-key=\"rowKey\"\n                        :columns-width=\"columnsWidth\"\n                        :obj-data=\"objData\"></table-body>\n                </div>\n                <table-summary\n                    v-if=\"showSummary && (data && data.length)\"\n                    fixed=\"left\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"fixedTableStyle\"\n                    :columns=\"leftFixedColumns\"\n                    :data=\"summaryData\"\n                    :columns-width=\"columnsWidth\"\n                    :style=\"{ 'margin-top': showHorizontalScrollBar ? scrollBarWidth + 'px' : 0 }\"\n                />\n            </div>\n            <div :class=\"[prefixCls + '-fixed-right']\" :style=\"fixedRightTableStyle\" v-if=\"isRightFixed\">\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\n                    <table-head\n                        fixed=\"right\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedRightTableStyle\"\n                        :columns=\"rightFixedColumns\"\n                        :column-rows=\"columnRows\"\n                        :fixed-column-rows=\"rightFixedColumnRows\"\n                        :obj-data=\"objData\"\n                        :columns-width=\"columnsWidth\"\n                        :data=\"rebuildData\"></table-head>\n                </div>\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedRightBody\" @mousewheel=\"handleFixedMousewheel\" @DOMMouseScroll=\"handleFixedMousewheel\">\n                    <table-body\n                        fixed=\"right\"\n                        :draggable=\"draggable\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedRightTableStyle\"\n                        :columns=\"rightFixedColumns\"\n                        :data=\"rebuildData\"\n                        :row-key=\"rowKey\"\n                        :columns-width=\"columnsWidth\"\n                        :obj-data=\"objData\"></table-body>\n                </div>\n                <table-summary\n                    v-if=\"showSummary && (data && data.length)\"\n                    fixed=\"right\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"fixedRightTableStyle\"\n                    :columns=\"rightFixedColumns\"\n                    :data=\"summaryData\"\n                    :columns-width=\"columnsWidth\"\n                    :style=\"{ 'margin-top': showHorizontalScrollBar ? scrollBarWidth + 'px' : 0 }\"\n                />\n            </div>\n            <div :class=\"[prefixCls + '-fixed-right-header']\" :style=\"fixedRightHeaderStyle\" v-if=\"isRightFixed\"></div>\n            <div :class=\"[prefixCls + '-footer']\" v-if=\"showSlotFooter\" ref=\"footer\"><slot name=\"footer\"></slot></div>\n        </div>\n        <div class=\"ivu-table-resize-line\" v-show=\"showResizeLine\" ref=\"resizeLine\"></div>\n        <div class=\"ivu-table-context-menu\" :style=\"contextMenuStyles\" v-if=\"showContextMenu\">\n            <Dropdown trigger=\"custom\" :visible=\"contextMenuVisible\" transfer @on-clickoutside=\"handleClickContextMenuOutside\">\n                <DropdownMenu slot=\"list\">\n                    <slot name=\"contextMenu\"></slot>\n                </DropdownMenu>\n            </Dropdown>\n        </div>\n        <Spin fix size=\"large\" v-if=\"loading\">\n            <slot name=\"loading\"></slot>\n        </Spin>\n    </div>\n</template>\n<script>\n    import tableHead from './table-head.vue';\n    import tableBody from './table-body.vue';\n    import tableSummary from './summary.vue';\n    import Dropdown from '../dropdown/dropdown.vue';\n    import DropdownMenu from '../dropdown/dropdown-menu.vue';\n    import Spin from '../spin/spin.vue';\n    import { oneOf, getStyle, deepCopy, getScrollBarSize } from '../../utils/assist';\n    import { on, off } from '../../utils/dom';\n    import Csv from '../../utils/csv';\n    import ExportCsv from './export-csv';\n    import Locale from '../../mixins/locale';\n    import elementResizeDetectorMaker from 'element-resize-detector';\n    import { getAllColumns, convertToRows, convertColumnOrder, getRandomStr } from './util';\n\n    const prefixCls = 'ivu-table';\n\n    let rowKey = 1;\n    let columnKey = 1;\n\n    export default {\n        name: 'Table',\n        mixins: [ Locale ],\n        components: { tableHead, tableBody, tableSummary, Spin, Dropdown, DropdownMenu },\n        provide () {\n            return {\n                tableRoot: this\n            };\n        },\n        props: {\n            data: {\n                type: Array,\n                default () {\n                    return [];\n                }\n            },\n            columns: {\n                type: Array,\n                default () {\n                    return [];\n                }\n            },\n            size: {\n                validator (value) {\n                    return oneOf(value, ['small', 'large', 'default']);\n                },\n                default () {\n                    return !this.$IVIEW || this.$IVIEW.size === '' ? 'default' : this.$IVIEW.size;\n                }\n            },\n            width: {\n                type: [Number, String]\n            },\n            height: {\n                type: [Number, String]\n            },\n            // 3.4.0\n            maxHeight: {\n                type: [Number, String]\n            },\n            stripe: {\n                type: Boolean,\n                default: false\n            },\n            border: {\n                type: Boolean,\n                default: false\n            },\n            showHeader: {\n                type: Boolean,\n                default: true\n            },\n            highlightRow: {\n                type: Boolean,\n                default: false\n            },\n            rowClassName: {\n                type: Function,\n                default () {\n                    return '';\n                }\n            },\n            context: {\n                type: Object\n            },\n            noDataText: {\n                type: String\n            },\n            noFilteredDataText: {\n                type: String\n            },\n            disabledHover: {\n                type: Boolean\n            },\n            loading: {\n                type: Boolean,\n                default: false\n            },\n            draggable: {\n                type: Boolean,\n                default: false\n            },\n            tooltipTheme: {\n                validator (value) {\n                    return oneOf(value, ['dark', 'light']);\n                },\n                default: 'dark'\n            },\n            // #5380 :key  index\n            // 4.1  String\n            rowKey: {\n                type: [Boolean, String],\n                default: false\n            },\n            // 4.0.0\n            spanMethod: {\n                type: Function\n            },\n            // 4.0.0\n            showSummary: {\n                type: Boolean,\n                default: false\n            },\n            // 4.0.0\n            summaryMethod: {\n                type: Function\n            },\n            // 4.0.0\n            sumText: {\n                type: String\n            },\n            // 4.1.0\n            indentSize: {\n                type: Number,\n                default: 16\n            },\n            // 4.1.0\n            loadData: {\n                type: Function\n            },\n            // 4.4.0\n            updateShowChildren: {\n                type: Boolean,\n                default: false\n            },\n            // 4.1.0\n            contextMenu: {\n                type: Boolean,\n                default: false\n            },\n            // 4.2.0\n            showContextMenu: {\n                type: Boolean,\n                default: false\n            }\n        },\n        data () {\n            const colsWithId = this.makeColumnsId(this.columns);\n            return {\n                ready: false,\n                tableWidth: 0,\n                columnsWidth: {},\n                prefixCls: prefixCls,\n                compiledUids: [],\n                objData: this.makeObjData(),     // checkbox or highlight-row\n                rebuildData: [],    // for sort or filter\n                cloneColumns: this.makeColumns(colsWithId),\n                columnRows: this.makeColumnRows(false, colsWithId),\n                leftFixedColumnRows: this.makeColumnRows('left', colsWithId),\n                rightFixedColumnRows: this.makeColumnRows('right', colsWithId),\n                allColumns: getAllColumns(colsWithId),  // for multiple table-head, get columns that have no children\n                showSlotHeader: true,\n                showSlotFooter: true,\n                bodyHeight: 0,\n                scrollBarWidth: getScrollBarSize(),\n                currentContext: this.context,\n                cloneData: deepCopy(this.data),    // when Cell has a button to delete row data, clickCurrentRow will throw an error, so clone a data\n                showVerticalScrollBar:false,\n                showHorizontalScrollBar:false,\n                headerWidth:0,\n                headerHeight:0,\n                showResizeLine: false,\n                contextMenuVisible: false,\n                contextMenuStyles: {\n                    top: 0,\n                    left: 0\n                }\n            };\n        },\n        computed: {\n            localeNoDataText () {\n                if (this.noDataText === undefined) {\n                    return this.t('i.table.noDataText');\n                } else {\n                    return this.noDataText;\n                }\n            },\n            localeNoFilteredDataText () {\n                if (this.noFilteredDataText === undefined) {\n                    return this.t('i.table.noFilteredDataText');\n                } else {\n                    return this.noFilteredDataText;\n                }\n            },\n            localeSumText () {\n                if (this.sumText === undefined) {\n                    return this.t('i.table.sumText');\n                } else {\n                    return this.sumText;\n                }\n            },\n            wrapClasses () {\n                return [\n                    `${prefixCls}-wrapper`,\n                    {\n                        [`${prefixCls}-hide`]: !this.ready,\n                        [`${prefixCls}-with-header`]: this.showSlotHeader,\n                        [`${prefixCls}-with-footer`]: this.showSlotFooter,\n                        [`${prefixCls}-with-summary`]: this.showSummary,\n                        [`${prefixCls}-wrapper-with-border`]: this.border\n                    }\n                ];\n            },\n            classes () {\n                return [\n                    `${prefixCls}`,\n                    {\n                        [`${prefixCls}-${this.size}`]: !!this.size,\n                        [`${prefixCls}-border`]: this.border,\n                        [`${prefixCls}-stripe`]: this.stripe,\n                        [`${prefixCls}-with-fixed-top`]: !!this.height\n                    }\n                ];\n            },\n            fixedHeaderClasses () {\n                return [\n                    `${prefixCls}-fixed-header`,\n                    {\n                        [`${prefixCls}-fixed-header-with-empty`]: !this.rebuildData.length\n                    }\n                ];\n            },\n            styles () {\n                let style = {};\n                let summaryHeight = 0;\n                if (this.showSummary) {\n                    if (this.size === 'small') summaryHeight = 40;\n                    else if (this.size === 'large') summaryHeight = 60;\n                    else summaryHeight = 48;\n                }\n                if (this.height) {\n                    let height = parseInt(this.height) + summaryHeight;\n                    style.height = `${height}px`;\n                }\n                if (this.maxHeight) {\n                    const maxHeight = parseInt(this.maxHeight) + summaryHeight;\n                    style.maxHeight = `${maxHeight}px`;\n                }\n                if (this.width) style.width = `${this.width}px`;\n                return style;\n            },\n            tableStyle () {\n                let style = {};\n                if (this.tableWidth !== 0) {\n                    let width = '';\n                    if (this.bodyHeight === 0) {\n                        width = this.tableWidth;\n                    } else {\n                        width = this.tableWidth - (this.showVerticalScrollBar?this.scrollBarWidth:0);\n                    }\n//                    const width = this.bodyHeight === 0 ? this.tableWidth : this.tableWidth - this.scrollBarWidth;\n                    style.width = `${width}px`;\n                }\n                return style;\n            },\n            tableHeaderStyle () {\n                let style = {};\n                if (this.tableWidth !== 0) {\n                    let width = '';\n                    width = this.tableWidth;\n                    style.width = `${width}px`;\n                }\n                return style;\n            },\n            fixedTableStyle () {\n                let style = {};\n                let width = 0;\n                this.leftFixedColumns.forEach((col) => {\n                    if (col.fixed && col.fixed === 'left') width += col._width;\n                });\n                style.width = `${width}px`;\n                return style;\n            },\n            fixedRightTableStyle () {\n                let style = {};\n                let width = 0;\n                this.rightFixedColumns.forEach((col) => {\n                    if (col.fixed && col.fixed === 'right') width += col._width;\n                });\n                //width += this.scrollBarWidth;\n                style.width = `${width}px`;\n                style.right = `${this.showVerticalScrollBar?this.scrollBarWidth:0}px`;\n                return style;\n            },\n            fixedRightHeaderStyle () {\n                let style = {};\n                let width = 0;\n                let height = this.headerHeight+1;\n                if(this.showVerticalScrollBar){\n                    width = this.scrollBarWidth;\n                }\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                return style;\n            },\n            bodyStyle () {\n                let style = {};\n                if (this.bodyHeight !== 0) {\n                    const height = this.bodyHeight;\n                    if (this.height) {\n                        style.height = `${height}px`;\n                    } else if (this.maxHeight) {\n                        style.maxHeight = `${height}px`;\n                    }\n                }\n                return style;\n            },\n            fixedBodyStyle () {\n                let style = {};\n                if (this.bodyHeight !== 0) {\n                    let height = this.bodyHeight - (this.showHorizontalScrollBar?this.scrollBarWidth:0);\n                    style.height = this.showHorizontalScrollBar ? `${height}px` : `${height - 1}px`;\n                }\n                return style;\n            },\n            leftFixedColumns () {\n                return convertColumnOrder(this.cloneColumns, 'left');\n            },\n            rightFixedColumns () {\n                return convertColumnOrder(this.cloneColumns, 'right');\n            },\n            isLeftFixed () {\n                return this.columns.some(col => col.fixed && col.fixed === 'left');\n            },\n            isRightFixed () {\n                return this.columns.some(col => col.fixed && col.fixed === 'right');\n            },\n            // for summary data\n            summaryData () {\n                if (!this.showSummary) return {};\n\n                let sums = {};\n                if (this.summaryMethod) {\n                    sums = this.summaryMethod({ columns: this.cloneColumns, data: this.rebuildData });\n                } else {\n                    this.cloneColumns.forEach((column, index) => {\n                        const key = column.key;\n                        if (index === 0) {\n                            sums[key] = {\n                                key: column.key,\n                                value: this.localeSumText\n                            };\n                            return;\n                        }\n                        const values = this.rebuildData.map(item => Number(item[column.key]));\n                        const precisions = [];\n                        let notNumber = true;\n                        values.forEach(value => {\n                            if (!isNaN(value)) {\n                                notNumber = false;\n                                let decimal = ('' + value).split('.')[1];\n                                precisions.push(decimal ? decimal.length : 0);\n                            }\n                        });\n                        const precision = Math.max.apply(null, precisions);\n                        if (!notNumber) {\n                            const currentValue = values.reduce((prev, curr) => {\n                                const value = Number(curr);\n                                if (!isNaN(value)) {\n                                    return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));\n                                } else {\n                                    return prev;\n                                }\n                            }, 0);\n                            sums[key] = {\n                                key: column.key,\n                                value: currentValue\n                            };\n                        } else {\n                            sums[key] = {\n                                key: column.key,\n                                value: ''\n                            };\n                        }\n                    });\n                }\n\n                return sums;\n            }\n        },\n        methods: {\n            rowClsName (index) {\n                return this.rowClassName(this.data[index], index);\n            },\n            handleResize () {\n                    //let tableWidth = parseInt(getStyle(this.$el, 'width')) - 1;\n                let tableWidth = this.$el.offsetWidth - 1;\n                let columnsWidth = {};\n                let sumMinWidth = 0;\n                let hasWidthColumns = [];\n                let noWidthColumns = [];\n                let maxWidthColumns = [];\n                let noMaxWidthColumns = [];\n                this.cloneColumns.forEach((col) => {\n                    if (col.width) {\n                        hasWidthColumns.push(col);\n                    }\n                    else{\n                        noWidthColumns.push(col);\n                        if (col.minWidth) {\n                            sumMinWidth += col.minWidth;\n                        }\n                        if (col.maxWidth) {\n                            maxWidthColumns.push(col);\n                        }\n                        else {\n                            noMaxWidthColumns.push(col);\n                        }\n                    }\n                    col._width = null;\n                });\n\n\n                let unUsableWidth = hasWidthColumns.map(cell => cell.width).reduce((a, b) => a + b, 0);\n                let usableWidth = tableWidth - unUsableWidth - sumMinWidth - (this.showVerticalScrollBar?this.scrollBarWidth:0) - 1;\n                let usableLength = noWidthColumns.length;\n                let columnWidth = 0;\n                if(usableWidth > 0 && usableLength > 0){\n                    columnWidth = parseInt(usableWidth / usableLength);\n                }\n\n\n                for (let i = 0; i < this.cloneColumns.length; i++) {\n                    const column = this.cloneColumns[i];\n                    let width = columnWidth + (column.minWidth?column.minWidth:0);\n                    if(column.width){\n                        width = column.width;\n                    }\n                    else{\n                        if (column._width) {\n                            width = column._width;\n                        }\n                        else {\n                            if (column.minWidth > width){\n                                width = column.minWidth;\n                            }\n                            else if (column.maxWidth < width){\n                                width = column.maxWidth;\n                            }\n\n                            if (usableWidth>0) {\n                                usableWidth -= width - (column.minWidth?column.minWidth:0);\n                                usableLength--;\n                                if (usableLength > 0) {\n                                    columnWidth = parseInt(usableWidth / usableLength);\n                                }\n                                else {\n                                    columnWidth = 0;\n                                }\n                            }\n                            else{\n                                columnWidth = 0;\n                            }\n                        }\n                    }\n\n                    column._width = width;\n\n                    columnsWidth[column._index] = {\n                        width: width\n                    };\n\n                }\n                if(usableWidth>0) {\n                    usableLength = noMaxWidthColumns.length;\n                    columnWidth = parseInt(usableWidth / usableLength);\n                    for (let i = 0; i < noMaxWidthColumns.length; i++) {\n                        const column = noMaxWidthColumns[i];\n                        let width = column._width + columnWidth;\n                        if (usableLength > 1) {\n                            usableLength--;\n                            usableWidth -= columnWidth;\n                            columnWidth = parseInt(usableWidth / usableLength);\n                        }\n                        else {\n                            columnWidth = 0;\n                        }\n\n                        column._width = width;\n\n                        columnsWidth[column._index] = {\n                            width: width\n                        };\n\n                    }\n                }\n\n                this.tableWidth = this.cloneColumns.map(cell => cell._width).reduce((a, b) => a + b, 0) + (this.showVerticalScrollBar?this.scrollBarWidth:0) + 1;\n                this.columnsWidth = columnsWidth;\n                this.fixedHeader();\n            },\n            handleMouseIn (_index, rowKey) {\n                if (this.disabledHover) return;\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                if (objData._isHover) return;\n                objData._isHover = true;\n            },\n            handleMouseOut (_index, rowKey) {\n                if (this.disabledHover) return;\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                objData._isHover = false;\n            },\n            //  highlightCurrentRow  clearCurrentRow\n            handleCurrentRow (type, _index, rowKey) {\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n\n                let oldData = null;\n                let oldIndex = -1;\n\n                for (let i in this.objData) {\n                    if (this.objData[i]._isHighlight) {\n                        oldIndex = parseInt(i);\n                        this.objData[i]._isHighlight = false;\n                        break;\n                    } else if (this.objData[i].children && this.objData[i].children.length) {\n                        const resetData = this.handleResetChildrenRow(this.objData[i]);\n                        if (resetData) oldData = JSON.parse(JSON.stringify(resetData));\n                    }\n                }\n                if (type === 'highlight') objData._isHighlight = true;\n                if (oldIndex >= 0) {\n                    oldData = JSON.parse(JSON.stringify(this.cloneData[oldIndex]));\n                }\n                const newData = type === 'highlight' ? rowKey ? JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))) : JSON.parse(JSON.stringify(this.cloneData[_index])) : null;\n                this.$emit('on-current-change', newData, oldData);\n            },\n            handleResetChildrenRow (objData) {\n                let data = null;\n                if (objData.children && objData.children.length) {\n                    for (let i = 0; i < objData.children.length; i++) {\n                        const item = objData.children[i];\n                        if (item._isHighlight) {\n                            item._isHighlight = false;\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.handleResetChildrenRow(item);\n                        }\n                    }\n                }\n                return data;\n            },\n            highlightCurrentRow (_index, rowKey) {\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                if (!this.highlightRow || objData._isHighlight) return;\n                this.handleCurrentRow('highlight', _index, rowKey);\n            },\n            clearCurrentRow () {\n                if (!this.highlightRow) return;\n                this.handleCurrentRow('clear');\n            },\n            clickCurrentRow (_index, rowKey) {\n                this.highlightCurrentRow (_index, rowKey);\n                if (rowKey) {\n                    this.$emit('on-row-click', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))));\n                } else {\n                    this.$emit('on-row-click', JSON.parse(JSON.stringify(this.cloneData[_index])), _index);\n                }\n            },\n            dblclickCurrentRow (_index, rowKey) {\n                this.highlightCurrentRow (_index, rowKey);\n                if (rowKey) {\n                    this.$emit('on-row-dblclick', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))));\n                } else {\n                    this.$emit('on-row-dblclick', JSON.parse(JSON.stringify(this.cloneData[_index])), _index);\n                }\n            },\n            contextmenuCurrentRow (_index, rowKey, event) {\n                if (this.contextMenuVisible) this.handleClickContextMenuOutside();\n                this.$nextTick(() => {\n                    const $TableWrap = this.$refs.tableWrap;\n                    const TableBounding = $TableWrap.getBoundingClientRect();\n                    const position = {\n                        left: `${event.clientX - TableBounding.left}px`,\n                        top: `${event.clientY - TableBounding.top}px`\n                    };\n                    this.contextMenuStyles = position;\n                    this.contextMenuVisible = true;\n                    if (rowKey) {\n                        this.$emit('on-contextmenu', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))), event, position);\n                    } else {\n                        this.$emit('on-contextmenu', JSON.parse(JSON.stringify(this.cloneData[_index])), event, position);\n                    }\n                });\n            },\n            getSelection () {\n                // \n                let selectionIndexes = [];\n                let selectionRowKeys = [];\n                for (let i in this.objData) {\n                    const objData = this.objData[i];\n                    if (objData._isChecked) selectionIndexes.push(parseInt(i));\n                    if (objData.children && objData.children.length) {\n                        selectionRowKeys = selectionRowKeys.concat(this.getSelectionChildrenRowKeys(objData, selectionRowKeys));\n                    }\n                }\n\n                //  RowKeys\n                selectionRowKeys = [...new Set(selectionRowKeys)];\n\n                let selection = [];\n\n                this.data.forEach((item, index) => {\n                    if (selectionIndexes.indexOf(index) > -1) {\n                        selection = selection.concat(item);\n                    }\n                    if (item.children && item.children.length && selectionRowKeys.length) {\n                        selection = selection.concat(this.getSelectionChildren(item, selection, selectionRowKeys));\n                    }\n                });\n\n\n                selection = [...new Set(selection)];\n                return JSON.parse(JSON.stringify(selection));\n            },\n            getSelectionChildrenRowKeys (objData, selectionRowKeys) {\n                if (objData.children && objData.children.length) {\n                    objData.children.forEach(item => {\n                        if (item._isChecked) selectionRowKeys.push(item._rowKey);\n                        if (item.children && item.children.length) {\n                            selectionRowKeys = selectionRowKeys.concat(this.getSelectionChildrenRowKeys(item, selectionRowKeys));\n                        }\n                    });\n                }\n                return selectionRowKeys;\n            },\n            getSelectionChildren (data, selection, selectionRowKeys) {\n                if (data.children && data.children.length) {\n                    data.children.forEach(item => {\n                        if (selectionRowKeys.indexOf(item[this.rowKey]) > -1) {\n                            selection = selection.concat(item);\n                        }\n                        if (item.children && item.children.length) {\n                            selection = selection.concat(this.getSelectionChildren(item, selection, selectionRowKeys));\n                        }\n                    });\n                }\n                return selection;\n            },\n            toggleSelect (_index, rowKey) {\n                let data = {};\n\n                if (rowKey) {\n                    data = this.getDataByRowKey(rowKey);\n                } else {\n                    for (let i in this.objData) {\n                        if (parseInt(i) === _index) {\n                            data = this.objData[i];\n                            break;\n                        }\n                    }\n                }\n                const status = !data._isChecked;\n\n                data._isChecked = status;\n                const selection = this.getSelection();\n                const selectedData = rowKey ? this.getBaseDataByRowKey(rowKey, this.data) : this.data[_index];\n                this.$emit(status ? 'on-select' : 'on-select-cancel', selection, JSON.parse(JSON.stringify(selectedData)));\n                this.$emit('on-selection-change', selection);\n            },\n            toggleExpand (_index) {\n                let data = {};\n\n                for (let i in this.objData) {\n                    if (parseInt(i) === _index) {\n                        data = this.objData[i];\n                        break;\n                    }\n                }\n                const status = !data._isExpanded;\n                this.objData[_index]._isExpanded = status;\n                this.$emit('on-expand', JSON.parse(JSON.stringify(this.cloneData[_index])), status);\n\n                if(this.height || this.maxHeight){\n                    this.$nextTick(()=>this.fixedBody());\n                }\n            },\n            toggleTree (rowKey) {\n                const data = this.getDataByRowKey(rowKey);\n                // async loading\n                if ('_loading' in data && data._loading) return;\n                if ('_loading' in data && !data._loading && data.children.length === 0) {\n                    const sourceData = this.getBaseDataByRowKey(rowKey, this.data);\n                    this.$set(sourceData, '_loading', true);\n                    this.loadData(sourceData, children => {\n                        this.$set(sourceData, '_loading', false);\n                        if (children.length) {\n                            this.$set(sourceData, 'children', children);\n                            this.$nextTick(() => {\n                                const newData = this.getDataByRowKey(rowKey);\n                                newData._isShowChildren = !newData._isShowChildren;\n                                //  updateDataStatus  _showChildren  @on-expand-tree\n                                //  _showChildren\n                                this.updateDataStatus(rowKey, '_showChildren', newData._isShowChildren);\n                            });\n                        }\n                    });\n                    return;\n                }\n\n                data._isShowChildren = !data._isShowChildren;\n                //  updateDataStatus  _showChildren  @on-expand-tree\n                // #675 updateShowChildren\n                if (this.updateShowChildren) this.updateDataStatus(rowKey, '_showChildren', data._isShowChildren);\n                this.$emit('on-expand-tree', rowKey, data._isShowChildren);\n            },\n            /**\n             * @description  _isShowChildren  data  _showChildren  data \n             * @param rowKey rowKey\n             * @param key \n             * @param value \n             * */\n            // todo \n            updateDataStatus (rowKey, key, value) {\n                const data = this.getBaseDataByRowKey(rowKey, this.data);\n                this.$set(data, key, value);\n            },\n            getDataByRowKey (rowKey, objData = this.objData) {\n                let data = null;\n                for (let i in objData) {\n                    const thisData = objData[i];\n                    if (thisData._rowKey === rowKey) {\n                        data = thisData;\n                        break;\n                    } else if (thisData.children && thisData.children.length) {\n                        data = this.getChildrenByRowKey(rowKey, thisData);\n                        if (data) {\n                            break;\n                        }\n                    }\n                }\n                return data;\n            },\n            getChildrenByRowKey (rowKey, objData) {\n                let data = null;\n                if (objData.children && objData.children.length) {\n                    for (let i = 0; i < objData.children.length; i++) {\n                        const item = objData.children[i];\n                        if (item._rowKey === rowKey) {\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.getChildrenByRowKey(rowKey, item);\n                            if (data) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                return data;\n            },\n            getBaseDataByRowKey (rowKey, sourceData = this.cloneData) {\n                let data = null;\n                for (let i = 0; i < sourceData.length; i++) {\n                    const thisData = sourceData[i];\n                    if (thisData[this.rowKey] === rowKey) {\n                        data = thisData;\n                        break;\n                    } else if (thisData.children && thisData.children.length) {\n                        data = this.getChildrenDataByRowKey(rowKey, thisData);\n                        if (data && data[this.rowKey] === rowKey) return data;\n                    }\n                }\n                return data;\n            },\n            getChildrenDataByRowKey (rowKey, cloneData) {\n                let data = null;\n                if (cloneData.children && cloneData.children.length) {\n                    for (let i = 0; i < cloneData.children.length; i++) {\n                        const item = cloneData.children[i];\n                        if (item[this.rowKey] === rowKey) {\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.getChildrenDataByRowKey(rowKey, item);\n                            if (data) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                return data;\n            },\n            selectAll (status) {\n                // this.rebuildData.forEach((data) => {\n                //     if(this.objData[data._index]._isDisabled){\n                //         this.objData[data._index]._isChecked = false;\n                //     }else{\n                //         this.objData[data._index]._isChecked = status;\n                //     }\n\n                // });\n                for (const data of this.rebuildData) {\n                    const objData = this.objData[data._index];\n                    if (!objData._isDisabled) {\n                        objData._isChecked = status;\n                    }\n                    if (data.children && data.children.length) {\n                        this.selectAllChildren(objData, status);\n                    }\n                }\n                const selection = this.getSelection();\n                if (status) {\n                    this.$emit('on-select-all', selection);\n                } else {\n                    this.$emit('on-select-all-cancel', selection);\n                }\n                this.$emit('on-selection-change', selection);\n            },\n            selectAllChildren (data, status) {\n                if (data.children && data.children.length) {\n                    data.children.map(item => {\n                        if (!item._isDisabled) {\n                            item._isChecked = status;\n                        }\n                        if (item.children && item.children.length) {\n                            this.selectAllChildren(item, status);\n                        }\n                    });\n                }\n            },\n            fixedHeader () {\n                if (this.height || this.maxHeight) {\n                    this.$nextTick(() => {\n                        const titleHeight = parseInt(getStyle(this.$refs.title, 'height')) || 0;\n                        const headerHeight = parseInt(getStyle(this.$refs.header, 'height')) || 0;\n                        const footerHeight = parseInt(getStyle(this.$refs.footer, 'height')) || 0;\n                        if (this.height) {\n                            this.bodyHeight = this.height - titleHeight - headerHeight - footerHeight;\n                        } else if (this.maxHeight) {\n                            this.bodyHeight = this.maxHeight - titleHeight - headerHeight - footerHeight;\n                        }\n                        this.$nextTick(()=>this.fixedBody());\n                    });\n                } else {\n                    this.bodyHeight = 0;\n                    this.$nextTick(()=>this.fixedBody());\n                }\n            },\n            fixedBody (){\n                if (this.$refs.header) {\n                    this.headerWidth = this.$refs.header.children[0].offsetWidth;\n                    this.headerHeight = this.$refs.header.children[0].offsetHeight;\n                    //this.showHorizontalScrollBar = this.headerWidth>this.$refs.header.offsetWidth;\n                }\n\n                if (!this.$refs.tbody || !this.data || this.data.length === 0) {\n                    this.showVerticalScrollBar = false;\n                }\n                else{\n                    let bodyContentEl = this.$refs.tbody.$el;\n                    let bodyEl = bodyContentEl.parentElement;\n                    let bodyContentHeight = bodyContentEl.offsetHeight;\n                    let bodyHeight = bodyEl.offsetHeight;\n\n                    this.showHorizontalScrollBar = bodyEl.offsetWidth < bodyContentEl.offsetWidth + (this.showVerticalScrollBar?this.scrollBarWidth:0);\n                    this.showVerticalScrollBar = this.bodyHeight? bodyHeight - (this.showHorizontalScrollBar?this.scrollBarWidth:0) < bodyContentHeight : false;\n\n                    if(this.showVerticalScrollBar){\n                        bodyEl.classList.add(this.prefixCls +'-overflowY');\n                    }else{\n                        bodyEl.classList.remove(this.prefixCls +'-overflowY');\n                    }\n                    if(this.showHorizontalScrollBar){\n                        bodyEl.classList.add(this.prefixCls +'-overflowX');\n                    }else{\n                        bodyEl.classList.remove(this.prefixCls +'-overflowX');\n                    }\n                }\n            },\n\n            hideColumnFilter () {\n                this.cloneColumns.forEach((col) => col._filterVisible = false);\n            },\n            handleBodyScroll (event) {\n                if (this.showHeader) this.$refs.header.scrollLeft = event.target.scrollLeft;\n                if (this.isLeftFixed) this.$refs.fixedBody.scrollTop = event.target.scrollTop;\n                if (this.isRightFixed) this.$refs.fixedRightBody.scrollTop = event.target.scrollTop;\n                if (this.showSummary && this.$refs.summary) this.$refs.summary.$el.scrollLeft = event.target.scrollLeft;\n                this.hideColumnFilter();\n            },\n            handleFixedMousewheel(event) {\n                let deltaY = event.deltaY;\n                if(!deltaY && event.detail){\n                    deltaY = event.detail * 40;\n                }\n                if(!deltaY && event.wheelDeltaY){\n                    deltaY = -event.wheelDeltaY;\n                }\n                if(!deltaY && event.wheelDelta){\n                    deltaY = -event.wheelDelta;\n                }\n                if(!deltaY) return;\n                const body = this.$refs.body;\n                const currentScrollTop = body.scrollTop;\n                if (deltaY < 0 && currentScrollTop !== 0) {\n                    event.preventDefault();\n                }\n                if (deltaY > 0 && body.scrollHeight - body.clientHeight > currentScrollTop) {\n                    event.preventDefault();\n                }\n                //body.scrollTop += deltaY;\n                let step = 0;\n                let timeId = setInterval(()=>{\n                    step += 5;\n                    if(deltaY>0){\n                        body.scrollTop += 2;\n                    }\n                    else{\n                        body.scrollTop -= 2;\n                    }\n                    if(step >= Math.abs(deltaY)){\n                        clearInterval(timeId);\n                    }\n                }, 5);\n            },\n            handleMouseWheel (event) {\n                const deltaX = event.deltaX;\n                const $body = this.$refs.body;\n\n                if (deltaX > 0) {\n                    $body.scrollLeft = $body.scrollLeft + 10;\n                } else {\n                    $body.scrollLeft = $body.scrollLeft - 10;\n                }\n            },\n            sortData (data, type, index) {\n                const key = this.cloneColumns[index].key;\n                data.sort((a, b) => {\n                    if (this.cloneColumns[index].sortMethod) {\n                        return this.cloneColumns[index].sortMethod(a[key], b[key], type);\n                    } else {\n                        if (type === 'asc') {\n                            return a[key] > b[key] ? 1 : -1;\n                        } else if (type === 'desc') {\n                            return a[key] < b[key] ? 1 : -1;\n                        }\n                    }\n                });\n                for (let i = 0; i < data.length; i++) {\n                    if (data[i].children && data[i].children.length) {\n                        data[i].children = this.sortData(data[i].children, type, index);\n                    }\n                }\n                return data;\n            },\n            handleSort (_index, type) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns.forEach((col) => col._sortType = 'normal');\n\n                const key = this.cloneColumns[index].key;\n                if (this.cloneColumns[index].sortable !== 'custom') {    // custom is for remote sort\n                    if (type === 'normal') {\n                        this.rebuildData = this.makeDataWithFilter();\n                    } else {\n                        this.rebuildData = this.sortData(this.rebuildData, type, index);\n                    }\n                }\n                this.cloneColumns[index]._sortType = type;\n\n                this.$emit('on-sort-change', {\n                    column: JSON.parse(JSON.stringify(this.allColumns[this.cloneColumns[index]._index])),\n                    key: key,\n                    order: type\n                });\n            },\n            handleFilterHide (index) {    // clear checked that not filter now\n                if (!this.cloneColumns[index]._isFiltered) this.cloneColumns[index]._filterChecked = [];\n            },\n            filterData (data, column) {\n                return data.filter((row) => {\n                    //\n                    if (typeof column.filterRemote === 'function') return true;\n\n                    let status = !column._filterChecked.length;\n                    for (let i = 0; i < column._filterChecked.length; i++) {\n                        status = column.filterMethod(column._filterChecked[i], row);\n                        if (status) break;\n                    }\n                    return status;\n                });\n            },\n            filterOtherData (data, index) {\n                let column = this.cloneColumns[index];\n                if (typeof column.filterRemote === 'function') {\n                    column.filterRemote.call(this.$parent, column._filterChecked, column.key, column);\n                }\n\n                this.cloneColumns.forEach((col, colIndex) => {\n                    if (colIndex !== index) {\n                        data = this.filterData(data, col);\n                    }\n                });\n                return data;\n            },\n            handleFilter (index) {\n                const column = this.cloneColumns[index];\n                let filterData = this.makeDataWithSort();\n\n                // filter others first, after filter this column\n                filterData = this.filterOtherData(filterData, index);\n                this.rebuildData = this.filterData(filterData, column);\n\n                this.cloneColumns[index]._isFiltered = true;\n                this.cloneColumns[index]._filterVisible = false;\n                this.$emit('on-filter-change', column);\n            },\n            /**\n             * #2832\n             *  column \n             *  $parent  index  cloneColumns  index \n             * \n             *  index\n             * */\n            GetOriginalIndex (_index) {\n                return this.cloneColumns.findIndex(item => item._index === _index);\n            },\n            handleFilterSelect (_index, value) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns[index]._filterChecked = [value];\n                this.handleFilter(index);\n            },\n            handleFilterReset (_index) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns[index]._isFiltered = false;\n                this.cloneColumns[index]._filterVisible = false;\n                this.cloneColumns[index]._filterChecked = [];\n\n                let filterData = this.makeDataWithSort();\n                filterData = this.filterOtherData(filterData, index);\n                this.rebuildData = filterData;\n                this.$emit('on-filter-change', this.cloneColumns[index]);\n            },\n            makeData () {\n                let data = deepCopy(this.data);\n                data.forEach((row, index) => {\n                    row._index = index;\n                    row._rowKey = (typeof this.rowKey) === 'string' ? row[this.rowKey] : rowKey++;\n                    if (row.children && row.children.length) {\n                        row.children = this.makeChildrenData(row);\n                    }\n                });\n                return data;\n            },\n            makeChildrenData (data) {\n                if (data.children && data.children.length) {\n                    return data.children.map((row, index) => {\n                        const newRow = deepCopy(row);\n                        newRow._index = index;\n                        newRow._rowKey = (typeof this.rowKey) === 'string' ? newRow[this.rowKey] : rowKey++;\n                        if (newRow.children && newRow.children.length) {\n                            newRow.children = this.makeChildrenData(newRow);\n                        }\n                        return newRow;\n                    });\n                } else {\n                    return data;\n                }\n            },\n            makeDataWithSort () {\n                let data = this.makeData();\n                let sortType = 'normal';\n                let sortIndex = -1;\n                let isCustom = false;\n\n                for (let i = 0; i < this.cloneColumns.length; i++) {\n                    if (this.cloneColumns[i]._sortType !== 'normal') {\n                        sortType = this.cloneColumns[i]._sortType;\n                        sortIndex = i;\n                        isCustom = this.cloneColumns[i].sortable === 'custom';\n                        break;\n                    }\n                }\n                if (sortType !== 'normal' && !isCustom) data =  this.sortData(data, sortType, sortIndex);\n                return data;\n            },\n            makeDataWithFilter () {\n                let data = this.makeData();\n                this.cloneColumns.forEach(col => data = this.filterData(data, col));\n                return data;\n            },\n            makeDataWithSortAndFilter () {\n                let data = this.makeDataWithSort();\n                this.cloneColumns.forEach(col => data = this.filterData(data, col));\n                return data;\n            },\n            makeObjBaseData (row) {\n                const newRow = deepCopy(row);\n                if ((typeof this.rowKey) === 'string') {\n                    newRow._rowKey = newRow[this.rowKey];\n                }\n                newRow._isHover = false;\n                if (newRow._disabled) {\n                    newRow._isDisabled = newRow._disabled;\n                } else {\n                    newRow._isDisabled = false;\n                }\n                if (newRow._checked) {\n                    newRow._isChecked = newRow._checked;\n                } else {\n                    newRow._isChecked = false;\n                }\n                if (newRow._expanded) {\n                    newRow._isExpanded = newRow._expanded;\n                } else {\n                    newRow._isExpanded = false;\n                }\n                if (newRow._highlight) {\n                    newRow._isHighlight = newRow._highlight;\n                } else {\n                    newRow._isHighlight = false;\n                }\n                return newRow;\n            },\n            makeObjData () {\n                let data = {};\n                this.data.forEach((row, index) => {\n                    const newRow = this.makeObjBaseData(row);\n                    if (newRow.children && newRow.children.length) {\n                        if (newRow._showChildren) {\n                            newRow._isShowChildren = newRow._showChildren;\n                        } else {\n                            newRow._isShowChildren = false;\n                        }\n                        newRow.children = this.makeChildrenObjData(newRow);\n                    }\n                    // else if ('_loading' in newRow && newRow.children && newRow.children.length === 0) {\n                    //     newRow._isShowChildren = false;\n                    // }\n                    data[index] = newRow;\n                });\n                return data;\n            },\n            makeChildrenObjData (data) {\n                if (data.children && data.children.length) {\n                    return data.children.map(row => {\n                        const newRow = this.makeObjBaseData(row);\n                        if (newRow._showChildren) {\n                            newRow._isShowChildren = newRow._showChildren;\n                        } else {\n                            newRow._isShowChildren = false;\n                        }\n                        if (newRow.children && newRow.children.length) {\n                            newRow.children = this.makeChildrenObjData(newRow);\n                        }\n                        return newRow;\n                    });\n                } else {\n                    return data;\n                }\n            },\n            //  id\n            makeColumnsId (columns) {\n                return columns.map(item => {\n                    if ('children' in item) this.makeColumnsId(item.children);\n                    item.__id = getRandomStr(6);\n                    return item;\n                });\n            },\n            makeColumns (cols) {\n                //  data this.allColumns  undefined\n                let columns = deepCopy(getAllColumns(cols));\n                let left = [];\n                let right = [];\n                let center = [];\n\n                columns.forEach((column, index) => {\n                    column._index = index;\n                    column._columnKey = columnKey++;\n                    column.width = parseInt(column.width);\n                    column._width = column.width ? column.width : '';    // update in handleResize()\n                    column._sortType = 'normal';\n                    column._filterVisible = false;\n                    column._isFiltered = false;\n                    column._filterChecked = [];\n\n                    if ('filterMultiple' in column) {\n                        column._filterMultiple = column.filterMultiple;\n                    } else {\n                        column._filterMultiple = true;\n                    }\n                    if ('filteredValue' in column) {\n                        column._filterChecked = column.filteredValue;\n                        column._isFiltered = true;\n                    }\n\n                    if ('sortType' in column) {\n                        column._sortType = column.sortType;\n                    }\n\n                    if (column.fixed && column.fixed === 'left') {\n                        left.push(column);\n                    } else if (column.fixed && column.fixed === 'right') {\n                        right.push(column);\n                    } else {\n                        center.push(column);\n                    }\n                });\n                return left.concat(center).concat(right);\n            },\n            // create a multiple table-head\n            makeColumnRows (fixedType, cols) {\n                return convertToRows(cols, fixedType);\n            },\n            exportCsv (params) {\n                if (params.filename) {\n                    if (params.filename.indexOf('.csv') === -1) {\n                        params.filename += '.csv';\n                    }\n                } else {\n                    params.filename = 'table.csv';\n                }\n\n                let columns = [];\n                let datas = [];\n                if (params.columns && params.data) {\n                    columns = params.columns;\n                    datas = params.data;\n                } else {\n                    columns = this.allColumns;\n                    if (!('original' in params)) params.original = true;\n                    datas = params.original ? this.data : this.rebuildData;\n                }\n\n                let noHeader = false;\n                if ('noHeader' in params) noHeader = params.noHeader;\n\n                const data = Csv(columns, datas, params, noHeader);\n                if (params.callback) params.callback(data);\n                else ExportCsv.download(params.filename, data);\n            },\n            dragAndDrop(a,b) {\n                this.$emit('on-drag-drop', a,b);\n            },\n            handleClickContextMenuOutside () {\n                this.contextMenuVisible = false;\n            }\n        },\n        created () {\n            if (!this.context) this.currentContext = this.$parent;\n            this.showSlotHeader = this.$slots.header !== undefined;\n            this.showSlotFooter = this.$slots.footer !== undefined;\n            this.rebuildData = this.makeDataWithSortAndFilter();\n        },\n        mounted () {\n            this.handleResize();\n            this.$nextTick(() => this.ready = true);\n\n            on(window, 'resize', this.handleResize);\n            this.observer = elementResizeDetectorMaker();\n            this.observer.listenTo(this.$el, this.handleResize);\n\n            this.$on('on-visible-change', (val) => {\n                if (val) {\n                    this.$nextTick(() => {\n                        this.handleResize();\n                    });\n                }\n            });\n        },\n        beforeDestroy () {\n            this.$off('on-visible-change');\n            off(window, 'resize', this.handleResize);\n            this.observer.removeAllListeners(this.$el);\n            this.observer.uninstall(this.$el);\n            this.observer = null;\n        },\n        watch: {\n            data: {\n                handler () {\n                    const oldDataLen = this.rebuildData.length;\n                    this.objData = this.makeObjData();\n                    this.rebuildData = this.makeDataWithSortAndFilter();\n                    this.handleResize();\n                    if (!oldDataLen) {\n                        this.fixedHeader();\n                    }\n                    // here will trigger before clickCurrentRow, so use async\n                    setTimeout(() => {\n                        this.cloneData = deepCopy(this.data);\n                    }, 0);\n                },\n                deep: true\n            },\n            columns: {\n                handler () {\n                    // todo \n                    const colsWithId = this.makeColumnsId(this.columns);\n                    this.allColumns = getAllColumns(colsWithId);\n                    this.cloneColumns = this.makeColumns(colsWithId);\n\n                    this.columnRows = this.makeColumnRows(false, colsWithId);\n                    this.leftFixedColumnRows = this.makeColumnRows('left', colsWithId);\n                    this.rightFixedColumnRows = this.makeColumnRows('right', colsWithId);\n                    this.rebuildData = this.makeDataWithSortAndFilter();\n                    this.handleResize();\n                },\n                deep: true\n            },\n            height () {\n                this.handleResize();\n            },\n            maxHeight () {\n                this.handleResize();\n            },\n            showHorizontalScrollBar () {\n                this.handleResize();\n            },\n            showVerticalScrollBar () {\n                this.handleResize();\n            }\n        }\n    };\n</script>\n"]}]}